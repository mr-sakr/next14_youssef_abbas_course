هذا المشروع هو تطبيق على كورس Next Js 14 لـ Youssef Abbas باللينك التالي : 
https://www.youtube.com/playlist?list=PL5gCk5NdNx58-q_gwuL6355afD8T_kIa0

الـ React هو Client Side Library ،
أما الـ Next.js هو Server Side Framework .
في الـ Next.js يتم بناء صفحات الويب في الـ Server ،
أما في React يتم بناء صفحات الويب في المتصفح ،

متطلبات الكورس : 
1- React.js
2- Typescript
3- Tailwind
4- Database SQL
5- API

اللي هنتعلمه في هذا الكورس : 
- Fundementals of Next,js 14
- Routing
- API with Next.js
- Prisma ORM
- Authentication & Authorization


هنثبت ال extensions التالية : 
1- ES7 + React/Redux/React-Native ( by dsznajder )
2- Prisma (by Prisma)
3- Tailwind Css Intellisense
4- Material Icon Theme (by philipp kief)


عشان نعمل Project جديد : 

`npx create-next-app@latest
`
`What is your project named? my-app
` ممكن نكتب فقط . لو عايزين نسطب ملفات البرنامج في نفس الفولدر اللي احنا فيه بدلاً من إنشاء فولدر مخصص للمشروع

```
Would you like to use TypeScript? No / Yes
Would you like to use ESLint? No / Yes
Would you like to use Tailwind CSS? No / Yes
Would you like to use `src/` directory? No / Yes
Would you like to use App Router? (recommended) No / Yes
Would you like to customize the default import alias (@/*)? No / Yes
What import alias would you like configured? @/*
```

--------------------------------------------------------------------------------------------



في هذا ال commit :
تم حذف أكواد الصفحة الرئيسية ، وكتابة أكواد جديدة بها لتهيئتها كالتالي : 

```tsx
const HomePage = () => {
  return (
    <div>
      <h1>Home Page</h1>
      <p>Welcome To Next Js</p>
    </div>
  )
}

export default HomePage
```


ومفس الحال لملف ال global.css حيث تم عمل متغير للون ال background والإعدادات الإفتراضية للـ padding و margin و box-sizing كالتالي : 

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --bg-color: #efefef;
}

body {
  background-color: var(--bg-color);
}

*{
  padding: 0;
  margin: 0;
  box-sizing: border-box;
}
```


وتم أيضاً حذف ال backgroundImage من ال Tailwind config ليصبح كالتالي : 
```ts
import type { Config } from "tailwindcss";

const config: Config = {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
    },
  },
  plugins: [],
};
export default config;
```

--------------------------------------------------------------------------------------------




يتم إنشاء الـ Route من خلال إنشاء فولدر بالمسار المطلوب داخل فولدر الـ app ، وداخل هذا الفولدر الجديد يتم إنشاء ملف بإسم page.tsx ، والذي يعتبر كملف index.html لهذه الصفحة ،
ويمكن عمل route داخلي عن طريق إنشاء فولدرات داخلية أيضاً ، 

فنقوم بإنشاء هذه الصفحات : 
about/page.tsx
admin/page.tsx
articles/page.tsx
articles/search/page.tsx
login/page.tsx
register/page.tsx


هنلاحظ أن الصفحات دي كلها عبارة عن Components داخل div
وبالتالي فأين الأكواد الكاملة من <html> و <body> وغيره ؟!!

الكود الأصلي للصفحة بيكون في ال layout واللي هيكون موجود في ملف layout.tsx بالخارج ، في المستوى الأول داخل فولدر ال app ،
وهذه الصفحات تعبر عن المتغير {children} حيث أن الكود كالتالي : 
```tsx
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}
```

ويمكن عمل layout لكل صفحة على حده ، وذلك من خلال إنشاء ملف داخل فولدر هذه الصفحة بإسم layout.tsx ، ولكن لن يحتوي على الأكواد الرئيسية ، لأنه سيظل الكود الاساسي داخل ال layout.tsx الخارجي ، والموجود مباشرة داخل فولدر ال app .

وممكن نغير ال title وال description للموقع من خلال ال metadata بملف ال layout .



عشان نستخدم أي font عايزينه من google fonts 
أولاً عمل import له ، قم تعريفه كـ const وتحديد خواصه ، ثم إستخدامه عن طريق ال className كالتالي : 
```tsx
import type { Metadata } from "next";
import { Cairo, Inter, Noto_Kufi_Arabic } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });
const KufiArabic = Noto_Kufi_Arabic({subsets:["arabic"], weight:['900', '500']});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={KufiArabic.className}>{children}</body>
    </html>
  );
}
```
كما يمكننا إستيراد أي font وإستخدامه داخل أي component ليس شرطاً في ال layout .


لو عايزين نعمل link للصفحة ولما نضغط عليه يحولنا عالصفحة المطلوبة ، في العادي بنستخدم <a></a>
ولكن لو استخدمناها سيعمل reload للصفحة وهذا غير مرغوب به في ال next.js لأننا المفترض مبدأنا أصبح أن يكون المشروع SPA ،
وبالتالي هناك built-in component اسمه <Link> بدلاً من <a> ،

نقوم الأن بوضع لينكات الصفحات بالصفحة الرئيسية للمشروع ، كالتالي : 

```tsx
import Link from "next/link"

const HomePage = () => {
  return (
    <div>
      <h1>Home Page</h1>
      <p>Welcome To Next Js</p>
      <div>
        <Link href="/admin">Go to admin page</Link>
        <Link href="/about">Go to about page</Link>
        <Link href="/articles">Go to articles page</Link>
        <Link href="/login">Go to login page</Link>
        <Link href="/register">Go to register page</Link>
      </div>
    </div>
  )
}

export default HomePage
```


------------------------------------------------------------------------------------------------------


هنعمل فولدر components بنفس مستوى app folder ، سيشمل على كل ال components

هنعمل فولدر بداخله باسم header وداخله هنعمل ملف Header.tsx وهيكون خاص بال Header Component 
وعند عمل import ممكن نستخدم @ في المسار للتعبير عن فولدر ال src كالتالي : 
```tsx
import Header from "@/components/header/Header"
```

ولإستخدام icons بالمشروع ، يمكننا إستخدام مكتبة react-icons الموجودة بهذا اللينك : 
https://www.npmjs.com/package/react-icons

حيث نقوم بهذا ال command : 
```cmd
> npm i react-icons
```
ويمكننا تصفح ال icons من خلال هذا الموقع التالي أيضاً : 
https://react-icons.github.io/react-icons/

فمثلاً لو نريد أيقونة Home سنبحث عنها ، سم نعمل import لها بال component كالتالي : 
```tsx
import { FaHome } from "react-icons/fa";
```
ثم نستخدمها هكذا : 
```tsx
<FaHome />
```

سنقوم أيضاً بكتابة أكواد ال Header وعمل ملف Css له ، ونعمل لملف ال css استيراد ونستخدمه داخل ال component ،
ويمكن إستخدام طريقة ال module لتجنب أي مشاكل ناتجة عن تكرار تسمية ال class في أي ملفات أخرى ، 

ولإستخدام طريقة module لابد من جعل اسم الملف يكون كالتالي : filename.module.css ،
فعلى سبيل المثال ، ملف ال Header Component الخاص بال css سيكون بإسم header.module.css ،

ونقوم بإستيراد الملف كالتالي : 
```tsx
import styles from "./header.module.css";
```

وعند الإستخدام سيكون بال className كالتالي {styles.header} ،
ويمكننا تغيير كلمة styles إلى أي اسم نريد ،


ولأننا نريد أن يكون الـ Header في كل الصفحات ، فيمكننا وضعه في ال Layout 
ويمكننا وضع ال navbar في component لوحده بإسم Navbar
ليكون كود ال Navbar كالتالي : 
```tsx
import Link from "next/link"
import { GrTechnology } from "react-icons/gr";
import styles from "./header.module.css";

const Navbar = () => {
  return (
    <nav className={styles.navbar}>
        <div>
            <Link href="/" className={styles.logo}>
                CLOUD
                <GrTechnology/>
                HOSTING
            </Link>
        </div>

        <ul className={styles.navLinks}>
            <Link className={styles.navLink} href="/">Home</Link>
            <Link className={styles.navLink} href="/articles">Articles</Link>
            <Link className={styles.navLink} href="/about">About</Link>
            <Link className={styles.navLink} href="/admin">Admin Dashboard</Link>
        </ul>
    </nav>
  )
}

export default Navbar
```

وكود ال Header.tsx كالتالي : 
```tsx
import Link from "next/link"
import styles from "./header.module.css";
import Navbar from "./Navbar";

const Header = () => {
  return (
    <header className={styles.header}>
        <Navbar/>
        <div className={styles.right}>
            <Link className={styles.btn} href="/login">Login</Link>
            <Link className={styles.btn} href="/register">Register</Link>
        </div>
    </header>
  )
}

export default Header
```


وكود ال header.module.css كالتالي : 
```css
.header{
    height: 100px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 40px;
    border-bottom: 4px solid rgb(144, 144, 144);
    background-color: rgb(227, 225, 225);
    position: relative;
}

.navbar{
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.logo{
    display: flex;
    align-items: center;
    font-size: 24;
    font-weight: bold;
    color: rgb(176, 15, 176);
}

.navLinks{
    margin-left: 30px;
}

.navLink{
    font-size: 20px;
    font-weight: 600;
    margin: 0 12px;
}

.right{
    display: flex;
    align-items: center;
    gap: 10px;
}

.btn{
    cursor: pointer;
    background-color: blue;
    color: white;
    border-radius: 10px;
    padding: 5px 10px;
    font-size: 21px;
    font-weight: 600;
    display: flex;
    align-items: center;
}

.btn:hover{
    background-color: darkblue;
}

.navLink:hover{
    color: darkblue;
}
```

وكود ال layout.tsx كالتالي : 

```tsx
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import Header from "@/components/header/Header";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <Header />
        <main>
          {children}
        </main>
      </body>
    </html>
  );
}
```



-------------------------------------------------------------------------------------------------



أي Component في ال next js هو عبارة عن server component ، عكس ال react js والذي يعتبر اي component به هو client component ،
وبالتالي لو عايز اطبع حاجة بال console.log  كالتالي : 
```tsx
const LoginPage = () => {
  console.log('hello');
  return (
    <div>LoginPage</div>
  )
}

export default LoginPage
```
فإنه عند زيارة الصفحة سيتم طباعة محتوى ال console وهو رسالة 'hello' داخل ال terminal وليس في ال console.log بال browser ،
وذلك لأن ال next.js هي server component ،

ولكن في بعض الأحيان نريد جعل ال component أن يكون client component ، 
فمثلاً لو نريد إستخدام onClick أو أياً من هذه ال events أو نريد إستخدام ال hooks فلابد من تحويل ال component من Server إلى Client Component ،
وذلك من خلال كتابة : 
```tsx
'use client'
```
في بداية ملف ال component ،
وبعدها سيمكنك إستخدام ال hooks وال events عادي جداً
وكمان ال رسائل ال console هتظهر ب console المتصفح ، وهتكون موجودة أيضاً بال terminal 
وذلك لأن التنفيذ سيكون على ال server أولاً سم سيجد النص 'use client' سيحول ال component إلى client component ،




عشان نجعل ال Navbar يكون Responsive Navbar : 

هنعمل ايقونة على شكل menu ، ونخليها display:none ، ونستخدم @media للشاشات الأصغر من 1080px ، 
فلو الشاشة اصغر من 1080px هنظهر الايقونة ونخفي ال logo ،

وهنحط ال nav links داخل div كالتالي ونديله class باسم navLinksWrapper 
ونخلي ال class ده في حالة الشاشات الاقل من 1080 يكون position absolute وبعض الخصائص الاخري ، ليكون مكانه اسفل ال navbar مباشرة ،
وهنخليه كمان لما يكون في الشاشات الصغيرة يكون الارتفاع بتاعه 0 ، وذلك من خلال خاصية clip-path والممكن استخدام اشكال لها من خلال موقع  https://bennettfeely.com/clippy/
وبالتالي ستختفي اللينكات في الشاشات الصغيرة ،


دلوقتى عايزين لما نكون في الشاشات الصغيرة ، نضغط على ايقونة menu فتظهر اللينكات ، 
يتم ذلك من خلال استخدم useState لمتغير ، عند الضغط علي الزر menu اجعل المتغير هذا true لو كان false او false لو كان true بمعني اجعله عكس نفسه ،
وفي نفس الوقت سنضع في ال div الخاص باللينكات clip-path والذي يقوم بفرد قائمة اللينكات ، وذلك من خلال style attribute مباشرة مع ال if condition 

ونستخدم onClick لتغيير قيمة ال toggle للتغيير من false ال true والعكس ، 



ويمكننا أيضاً إستخدام ايقونة اغلاق اللينكات ، لو القائمة مفتوحة يظهر ايقونة الاغلاق ، لو القائمة مفتوحة يظهر ايقونة ال menue 

لتكون أكواد ال Navbar هكذا : 
```tsx
'use client'
import Link from "next/link"
import { GrTechnology } from "react-icons/gr";
import styles from "./header.module.css";
import { AiOutlineMenu } from "react-icons/ai";
import { useState } from "react";
import { IoMdClose } from "react-icons/io";

const Navbar = () => {
    const [toggle, setToggle] = useState(false)
    return (
        <nav className={styles.navbar}>
            <div>
                <Link href="/" className={styles.logo}>
                    CLOUD
                    <GrTechnology/>
                    HOSTING
                </Link>

                <div className={styles.menu}>
                    {toggle ? <IoMdClose onClick={() => setToggle(prev => !prev) } /> : <AiOutlineMenu onClick={() => setToggle(prev => !prev) } />}
                </div>
            </div>
            
            <div className={styles.navLinlsWrapper} style={{clipPath: toggle && "polygon(0 0, 100% 0, 100% 100%, 0% 100%)" || ""}}>
                <ul className={styles.navLinks}>
                    <Link onClick={() => setToggle(false)} className={styles.navLink} href="/">Home</Link>
                    <Link onClick={() => setToggle(false)} className={styles.navLink} href="/articles">Articles</Link>
                    <Link onClick={() => setToggle(false)} className={styles.navLink} href="/about">About</Link>
                    <Link onClick={() => setToggle(false)} className={styles.navLink} href="/admin">Admin Dashboard</Link>
                </ul>
            </div>
            
        </nav>
    )
}

export default Navbar
```


وأكواد ال header.module.css هكذا : 
```css
.header{
    height: 100px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 40px;
    border-bottom: 4px solid rgb(144, 144, 144);
    background-color: rgb(227, 225, 225);
    position: relative;
}

.navbar{
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.logo{
    display: flex;
    align-items: center;
    font-size: 24;
    font-weight: bold;
    color: rgb(176, 15, 176);
}

.menu{
    font-size: 40px;
    font-weight: bold;
    color: #202121;
    cursor: pointer;
    display: none;
}

.navLinks{
    margin-left: 30px;
}

.navLink{
    font-size: 20px;
    font-weight: 600;
    margin: 0 12px;
}

.right{
    display: flex;
    align-items: center;
    gap: 10px;
}

.btn{
    cursor: pointer;
    background-color: blue;
    color: white;
    border-radius: 10px;
    padding: 5px 10px;
    font-size: 21px;
    font-weight: 600;
    display: flex;
    align-items: center;
}

.btn:hover{
    background-color: darkblue;
}

.navLink:hover{
    color: darkblue;
}


@media(max-width: 1080px){
    .logo{
        display: none;
    }
    .menu{
        display: block;
    }
    
    .navLinlsWrapper{
        position: absolute;
        left: 0;
        top: 100%;
        width: 100%;
        transition: all .3s ease-in;
        z-index: 100;
        background-color: rgb(227, 225, 225);
        clip-path: polygon(0 0, 100% 0, 100% 0, 0 0);
    }

    .navLinks{
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: start;
        margin-left: 0;
        padding-left: 30px;
        padding-bottom: 10px;
    }
    .navLink{
        padding: 0;
        margin: 12px 0;
    }
}
```



-------------------------------------------------------------------------------------------------------




في هذا ال commit هنتكلم عن ال data fetching 

ففي بعض الأحيان بنحتاج نرسل request ل api معين لنأخذ منه البيانات ، 
فمثلاً لو عايزين نجلب البيانات ل ArticlesPage ،
عندنا fetch() function ، والذي يمكننا من إرسال request ل api ونأخذ ال response من ال api ،
وهذه ال function تعمل في ال frontend وليس ال backend ،
ولكن يمكننا إستخدام ال fetch() function بال next.js حيث هناك بعض التعديلات عليها ،

ولإستخدامها ، يمكننا تمرير لينك لها ،
يمكننا الإعتماد على بيانات fake من خلال الموقع  https://jsonplaceholder.typicode.com/ 

ونقوم بتحويل ال function component لتكون async ، وال fetch تأخذ await هكذا : 
```tsx
const ArticlesPage = async () => {
  const response = await fetch("https://jsonplaceholder.typicode.com/posts");
  const articles = await response.json();
  console.log(articles);
  
  return (
    <div>ArticlesPage</div>
  )
}

export default ArticlesPage
```


ولإستخدام البيانات وطباعتها بال component سنستخدم ال map ، 
ولكن سنلاحظ أننا عندما نكتب الكود فإن ال typescript لا تقترح علينا أي property وذلك لأننا لم نعمل type لل article ،

وعليه فيمكننا عمل type لل article في بداية ملف ال article component اولاً ليكون الكود كالتالي : 

```tsx
type Article = {
  id:number;
  userId:number;
  title:string;
  body:string
}

const ArticlesPage = async () => {
  const response = await fetch("https://jsonplaceholder.typicode.com/posts");
  const articles:Article[] = await response.json();

  return (
    <section>
      {articles.map(item=> <h1 key={item.id}>{item.title}</h1> )}
    </section>
  )
}

export default ArticlesPage
```


ولكن للتنظيم ، هنعمل  ArticleItem component داخل فولدر articles داخل فولدر components وليس ال app ، بمعنى اننا سنقوم بإنشاء فولدر لل articles داخل ال components 
وبإستخدام ال tailwind سنقوم بتصميم هذا ال component ،

وللتنظيم أيضاً وعدم التكرار ، عندنا ال type Article اللي هنحتاجه في ال ArticleItem وفي ال articles ،
ممكن نعمل فولدر باسم utils داخل ال src ، وداخل ال utlis هنعمل ملف باسم types.ts واللي هنحدد فيه كل ال types الخاصة بالمشروع ، ليكون كالتالي : 

```ts
export type Article = {
    id:number;
    userId:number;
    title:string;
    body:string
    }
```

ثم نحذف ال Article types من الملفات الاخرى ونعمل import لل Article type الموجود بال utils 

وفي ال ArticleItem هنستخدم ال interface عشان نحدد انواع بيانات ال article كالتالي : 
```tsx
import { Article } from "@/utils/types"

interface ArticleItemProps{
    article: Article
}
const ArticleItem = ({article}:ArticleItemProps) => {
    return (
        <div>
            Article
        </div>
    )
}
```


وبالتالي ستكون أكواد ال src/utils/types.ts كالتالي : 
```ts
export type Article = {
    id:number;
    userId:number;
    title:string;
    body:string
    }
```


وأكواد ال ArticlesPage كالتالي : 

```tsx
import ArticleItem from "@/components/articles/ArticleItem";
import { Article } from "@/utils/types";

const ArticlesPage = async () => {
  const response = await fetch("https://jsonplaceholder.typicode.com/posts");
  const articles: Article[] = await response.json();

  return (
    <section className="container m-auto px-5">
      <div className="flex items-center justify-center flex-wrap gap-7">
        {articles.map((item) => (
          <ArticleItem article={item} key={item.id} />
        ))}
      </div>
    </section>
  );
};

export default ArticlesPage;
```

وأكواد ال ArticleItem كالتالي : 

```tsx
import Link from "next/link"
import { Article } from "@/utils/types"

interface ArticleItemProps{
    article: Article
}
const ArticleItem = ({article}:ArticleItemProps) => {
    return (
        <div className="p-5 rounded-lg my-1 shadow-lg border-2 border-gray-400 hover:bg-slate-200 w-full md:w-2/5 lg:w-1/4">
            <h3 className="text-xl font-bold text-gray-900">{article.title}</h3>
            <p className="my-2 text-xl text-gray-700 p-1 line-clamp-1">{article.body}</p>
            <Link className="text-xl bg-purple-700 hover:bg-purple-800 w-full block text-center p-1 text-white rounded-lg" href={`/articles/${article.id}`}>Read More</Link>
        </div>
    )
}

export default ArticleItem
```





----------------------------------------------------------------------------------------------------





هناقش الـ Error Handling في هذا ال Commit : 
فعندما نرسل request لـ api معين ، قد لا نستقبل ال response بشكل صحيح ، فقد يعطينا Error ،
نتيجة لمشاكل بقاعدة البيانات مثلاً أو أياً من هذا القبيل ، 

فبعد ال fetch نقوم بعمل check لو ال response غير صحيح فنفذ throw new Error كالتالي : 
```tsx
  const response = await fetch("https://jsonplaceholder.typicode.com/posts");

  if(!response.ok){
    throw new Error("Failed To Fetch Articles");
  }
```

فلو هناك أي مشكلة ستظهر صفحة خطأ ، ولإنشاء صفحة Custom Error Page تظهر لل client ، نقوم بإنشاء ملف بإسم error.tsx في ال app folder ،
وهذا ال Error Component لازم يكون Client Component وذلك بإضافة 'use client'  ، ليكون ال component كالتالي :  
```tsx
'use client'
import Link from "next/link"

const ErrorPage = () => {
  return (
    <div className="pt-7 text-center">
        <div className="text-3xl text-red-600 font-semibold">
            Something Went Wrong
        </div>
        <Link href="/" className="text-xl underline text-blue-700 block mt-6">Go To Home Page</Link>
    </div>
  )
}

export default ErrorPage
```


ولجعل صفحة ال Error Page تظهر رسائل متغيرة ، بحيث تعرض الرسالة التي أعطيناها في ال throw new error("...") function يكون ذلك من خلال error.message 
ولكن لابد من عمل ال interface وتحديد القيم أولاً 
كما يمكننا عمل زر reset والذي يقوم بعمل re-render والذي يحاول عمل ال request مرة اخرى 
ليكون الكود كالتالي : 

```tsx
'use client'
import Link from "next/link"

interface ErrorPageProps{
    error: Error;
    reset: () => void;
}

const ErrorPage = ({error, reset} : ErrorPageProps) => {
  return (
    <div className="pt-7 text-center">
        <div className="text-3xl text-red-600 font-semibold">
            Something Went Wrong
        </div>
        <h2 className="text-gray-700 my-3 text-xl">Error Message : {error.message}</h2>
        <Link href="/" className="text-xl underline text-blue-700 block mt-6">Go To Home Page</Link>
    </div>
  )
}

export default ErrorPage
```

ولو عايز Custom Error Page لـ Route معين ، بمعني عايز صفحة خطأ مختلفة لكل route ،
يمكن ذلك من خلال إنشاء ملف بإسم error.tsx داخل فولدر ال route المطلوب .





-------------------------------------------------------------------






نتكلم في هذا ال commit عن ال dynamic route ، 
يتم ذلك من خلال إنشاء فولدر بإسم [id] أو أي اسم تريد ، المهم يكون بين قوسين [] ، وداخل هذا الفولدر نقوم بإنشاء ملف page.tsx ،

فمثلاً في هذا المشروع ، داخل ال articles هنعمل فولدر جديد بإسم [id] ، وداخله ملف page.tsx ،

وللحصول على بيانات ال page الخاصة بهذا ال id ، يكون من خلال props كالتالي : 
```tsx
const SingleArticelPage = (props:any) => {
    console.log(props);
    
  return (
    <div>SingleArticelPage</div>
  )
}

export default SingleArticelPage
```

ستظهر هذه النتيجة في ال Terminal
```cmd
{ params: { id: '2' }, searchParams: {} }
```

وذلك لأن اللينك كالتالي : http://localhost:3000/articles/2

بمعنى أن ال props object هيرجع قيمتين : params & searchParams
وال searchParams خاصة بال query string ، فمثلاً اللينك التالي : http://localhost:3000/articles/2?pageNumber=20
سيعرض النتيجة التالية : 
```cmd
{ params: { id: '2' }, searchParams: { pageNumber: '20' } }
```
حيث أنه يكون لدينا key و value ، 


هنعمل ال SingleArticlePage كالتالي ، مع إستخدام ال interface لل params فقط كالتالي : 

```tsx
interface SingleArticelPageProps{
    params:{
        id:string
    }
}

const SingleArticelPage = ({params}:SingleArticelPageProps) => {
    
  return (
    <div>ID = {params.id}</div>
  )
}

export default SingleArticelPage
```

ولعمل fetch للبيانات بإستخدام ال params.id يكون كالتالي : 
```tsx
import { Article } from "@/utils/types";

interface SingleArticelPageProps{
    params:{ id:string }
}

const SingleArticelPage = async ({params}:SingleArticelPageProps) => {
    const response = await fetch(`https://jsonplaceholder.typicode.com/posts/${params.id}`);
    if(!response.ok){
        throw new Error('Failed To Fetch Article Details');
    }
    const article: Article = await response.json();

  return (
    <section>
        <div>
            <h1>{article.title}</h1>
        </div>
        <div>1/1/2024</div>
        <p>{article.body}</p>
    </section>
  )
}

export default SingleArticelPage
```

ثم نقوم بإضافة أكواد ال Tailwind للتصميم كالتالي : 

```tsx
import { Article } from "@/utils/types";

interface SingleArticelPageProps{
    params:{ id:string }
}

const SingleArticelPage = async ({params}:SingleArticelPageProps) => {
    const response = await fetch(`https://jsonplaceholder.typicode.com/posts/${params.id}`);
    if(!response.ok){
        throw new Error('Failed To Fetch Article Details');
    }
    const article: Article = await response.json();

  return (
    <section className="min-h-[calc(100vh-150px)] container m-auto w-full px-5 pt-8 md:w-3/4">
        <div className="bg-white p-7 rounded-lg">
            <h1 className="text-3xl font-bold text-gray-700 mb-2">{article.title}</h1>
            <div className="text-gray-400">1/1/2024</div>
            <p className="text-gray-800 text-xl mt-5">{article.body}</p>
        </div>
    </section>
  )
}
```




----------------------------------------------------------------------------------------------------------------





في هذا ال commit هنعمل custom not-found page كصفحة افتراضيه عند زيارة صفحة غير موجودة ، 
وتتم من خلال إنشاء ملف داخل app بإسم not-found.tsx لا يمكن تغيير هذا الإسم ،

ولو عايز عايزين صفحة not-found مخصصة لكل route ، يمكن عمل ذلك بإنشاء صفحة ال not-found داخل فولدر ال route هذا ،

```tsx
import Link from "next/link"

const NotFound = () => {
  return (
    <section className="flex justify-center items-center flex-col">
        <h1 className="text-7xl text-gray-800 font-bold">404</h1>
        <p className="text-gray-500 text-3xl mt-2 mb-5">Not Found</p>
        <Link href="/" className="text-xl underline text-blue-700">Go To Home Page</Link>
    </section>
  )
}

export default NotFound
```


هنعمل بعد كده footer component كالتالي : 
```tsx
const Footer = () => {
  return (
    <div className='h-[50px] flex justify-center items-center text-white bg-gray-700'>
        Copyright 2024 Cloud Hosting
    </div>
  )
}

export default Footer
```

وهنضيف ال class التالي min-h-[calc(100vh-150px)] لل not-found page أو أي صفحة تقل ارتفاعها عن 100vh حتى لا يكون ال footer مرتفع بمنتصف الصفحة او اعلى ، كالتالي : 
```tsx
import Link from "next/link"

const NotFound = () => {
  return (
    <section className="min-h-[calc(100vh-150px)] flex justify-center items-center flex-col">
        <h1 className="text-7xl text-gray-800 font-bold">404</h1>
        <p className="text-gray-500 text-3xl mt-2 mb-5">Not Found</p>
        <Link href="/" className="text-xl underline text-blue-700">Go To Home Page</Link>
    </section>
  )
}

export default NotFound
```





----------------------------------------------------------------------------------------------




هنتعامل مع ال Image Component في هذا ال commit ،
وهو بديل ال img tag ، يمكننا كتابة img tag ولكن الأفضل والأنسب أن نستخدم ال Image Component ،
لأنه يعطينا إمكانيات أكثر ، ويقلل حجم الصور وبالتالي تحميل الصفحة يكون أسرع ،

ولابد من تحديد ال src وال alt الخاصة بالصورة ، 
ويمكننا أيضاً إستخدام priority ، والتي تكون قيمته الإفتراضية false ، 
حيث أن ال next.js يعمل lazy loading للصور ،
وهي تعني أن يتم تحميل ال content لل page أولاً ثم يتم تحميل الصورة بعد ذلك ، ولكن لو عايز الأولوية تكون للصورة أولاً فيمكنك إضافة attr بإسم priority ، ويمكن إضافة قيمة له = true 
ولو تركناها بدون قيمة ستكون = true أيضاً ، 

ليكون الكود كالتالي : 
```tsx
import Image from "next/image"
import Logo from '../../../public/logo.png'

const AboutPage = () => {
  return (
    <section className="min-h-[calc(100vh-150px)] ">
      <h1 className="text-3xl font-bold text-gray-800 p-5">AboutPage</h1>
      <div>
        <Image src={Logo} alt="Logo-Image" width={500} height={500} priority/>
      </div>
    </section>
  )
}

export default AboutPage
```

لاحظ أننا قمنا بعمل import للصورة واستخدمناها في ال component ،
وهذا يمكن عمله في الصور ال localc ، والمخزنة داخل ال public ومعروف اسمها مسبقاً ،

ولكن في بعض الأحيان ممكن ناخد الصور من موقع خارجي أو من Server أخر ،
وفي هذه الحالة لابد من إضافة بيانات ال remote server لملف ال next.config.ts ، كالتالي : 

* هذا مجرد مثال لن نطبقه عالمشروع
```ts
const nextConfig = {
    images: {
        remotePatterns: [
            {
            protocol: 'https',
            hostname: 'your-remote-serve.com',
            },
        ],
    },
};
```

وال width وال height اخيارية في حالة عدم اخذ الصورة من ال remote serve .





--------------------------------------------------------------------------------------




سنقوم في هذا ال commit بعمل تصميم لل home page ، والتي تكون عبارة عن صفحة ال page.tsx الموجودة داخل ال app مباشرة .

هنعمل فولدر جديد باسم home داخل ال components والذي سيحتوي على كل ال components الخاصة بال HomePage ،

هنعمل Hero component كالتالي : 
```tsx
import { TiTick } from "react-icons/ti";
import Image from "next/image";
import Logo from "../../../public/logo.png";

const Hero = () => {
  return (
    <div className="h-[calc(100vh-100px)] flex justify-around items-center text-[rgb(10,9,9)] p-[0_30px] max-md:h-auto max-md:flex-col max-md:justify-center max-md:p-[0_15px] ">
      <div className="max-md:bg-[snow] max-md:m-[20px_0] rounded-[20px] w-full p-[15px]">
        <h1 className="text-[44px] font-bold text-black">Cloud Hosting</h1>
        <p className="text-xl">The Best web Hosting Solution For Your Online Success</p>

        <div className="p-5 mt-4">
          <div className="flex items-center text-xl font-bold mb-1 text-[#555]">
            <TiTick /> Easy To Use Control Panel
          </div>
          <div className="flex items-center text-xl font-bold mb-1 text-[#555]">
            <TiTick /> Secure Hosting
          </div>
          <div className="flex items-center text-xl font-bold mb-1 text-[#555]">
            <TiTick /> Website Maintenance
          </div>
        </div>
      </div>

      <div>
        <Image src={Logo} alt="Logo Image" width={500} height={500} />
      </div>
    </div>
  );
};

export default Hero;
```

ونعمل component باسم WebHostingPlan كالتالي : 
```tsx
import { TiTick } from "react-icons/ti"

const WebHostingPlan = () => {
  return (
    <div className="flex flex-col justify-center items-center w-3/4 rounded p-4 bg-gray-200 mb-7 md:w-2/4 lg:w-1/4">
        <h3 className="text-3xl font-bold text-purple-900 ">Premium</h3>
        <strong className="text-3xl font-bold text-gray-900 my-5">
            $4.99/mo
        </strong>
        <span className="bg-red-200 text-red-900 rounded-full px-2 py-1 font-semibold">
            10% OFF
        </span>
        <div className="mt-6">
            <h5 className="text-2xl mb-1 font-semibold text-purple-700 ">
                Top Features
            </h5>
            <div className="flex items-center text-green-700 mb-1 ps-3">
                <TiTick /> 100 Website
            </div>
            <div className="flex items-center text-green-700 mb-1 ps-3">
                <TiTick /> 100 GB SSD Storage
            </div>
            <div className="flex items-center text-green-700 mb-1 ps-3">
                <TiTick /> Weekly Backups
            </div>
            <div className="flex items-center text-green-700 mb-1 ps-3">
                <TiTick /> Unlimited Bandwidth
            </div>
            <div className="flex items-center text-green-700 mb-1 ps-3">
                <TiTick /> Free SSL 
            </div>
            <div className="flex items-center text-green-700 mb-1 ps-3">
                <TiTick /> Free Email
            </div>
        </div>

        <button className="mt-4 w-full border-2 border-gray-900 text-gray-900 text-2xl font-bold p-1 rounded-full hover:text-white hover:bg-gray-900 transition">
            BUY NOW
        </button>
    </div>
  )
}

export default WebHostingPlan
```

لتكون صفحة ال HomePage كالتالي : 
```tsx
import Hero from "@/components/home/Hero"
import WebHostingPlan from "@/components/home/WebHostingPlan"

const HomePage = () => {
  return (
    <section>
      <Hero/>
      <h2 className="text-center mt-10 text-3xl font-bold">
        Choose Your Web Hosting Plan
      </h2>
      <div className="container m-auto flex justify-center items-center my-7 flex-wrap md:gap-7">
        <WebHostingPlan />
        <WebHostingPlan />
        <WebHostingPlan />
      </div>
    </section>

  )
}

export default HomePage
```

ويمكن تصميم ال About Page لتكون كالتالي : 
```tsx
const AboutPage = () => {
  return (
    <section className="min-h-[calc(100vh-150px)] container m-auto">
      <h1 className="text-3xl font-bold text-gray-800 p-5">About This App</h1>
      <p className="px-5 text-gray-600 text-xl">
        The Best Web Hosting Solution For Your Online Success 
      </p>
    </section>
  )
}

export default AboutPage
```






--------------------------------------------------------------------------------------------------------






هنتكلم في ال commit ده عن ال Routing بشكل أكبر ،
مثل : 
Route Group : (folder)

هو وضع الفولدرات الموجودة في ال app اللي ليهم علاقة ببعض في فولدر واحد ، دون التأثير على ال Route ، 
مثلاً فولدر login وفولدر register ممكن أجمعهم الاتنين داخل فولدر باسم auth ، ولكن لو اسم الفولدر هيكون auth هتضر تغير ال route ليكون domain.com/auth/login ،
احنا عايزين نجمعهم مع بعض في فولدر بدون التأثير على ال Route ، وبالتالي هنستخدم ال Route Group عن طريق وضع الفولدرات المتشابهة والمتشاركة سوياً في فولدر ، واسم الفولدر يكون بين () ، وبالتالي هذا الفولدر سيكون اسمه (auth) ،



Private Folder : _folder

لو عايزين نعمل فولدر لتخزين ملفات css فيه مثلاً ، أو componens وهكذا ، بمعنى انه لن يكون route ولا أي ملفات داخله ستكون routes فيمكننا إستخدام Private Folder ،
والذي يتم إستخدامه عن طريق كتابة underscore _ قبل الاسم مباشرة ، كالتالي : 
_css & _components & _utils .....


Catch-All Route Segment : [...folder]

وهو لو عندي route كالتالي : domain.com/cart/products/car/ford/model1
وملفات المشروع عندي app/cart/products فقط ، 
ونريد عرض صفحة products وإستخدام باقي ال route segments بهذه الصفحة من خلال ال params ، 
حيث أنه لا يوجد صفحات بإسم car او ford او model1 ، ولكن هذه ستكون segment فقط يتم عرضها بصفحة ال products ،

فيتم ذلك من خلال جعل فولدر products بالمسمى التالي : [...products] ، وبالتالي فإن أي route segment بعد هذا ال route سيعتبر ضمن عناصر array بإسم products ،
حيث أننا لو مررنا props وطبعنها في ال console ستظهر بال terminal  أنه سيرجع params object ، يحتوي على products object ، والذي ستكون قيمته array ، وكل segment عبارة عن عنصر من هذا ال array ، بداية من ال products segment ليكون كالتالي : 
```
params: { products: ['products', 'car', 'ford', 'model1'] },
searchParams: {}
```

ولكن قلما نستخدم هذا ال techinque ، ولكن قد نجده في ال packadges الخاصة بال authentication وال authorization ، مثل ال next-auth و clerck ،


Optional Catch-All Route Segment : [[...folder]]

وهي نفس ال technique السابقة ، إلا أن ال route يحولنا على صفحة products لو كان ال route كالتالي : domain.com/cart فقط ،
ولا يوجد cart/products كما بالسابق ، وذلك في حالة أن ال cart لا يحتوي على page.tsx بل يحتوي على فولدر products ، 
فلجعل ال route يفتح صفحة products ايضاً في هذه الحالة ، فعلينا إستخدام Optional Catch-All Route Segment ، حيث سيتم كتابة فولدر products بهذا الشكل : 
```
[[...products]]
```

ويجب ملاحظة أن ال params لابد أن تكون optional ايضاً عند تعريفها واستخدامها بال interface وال map function كالتالي : 
```tsx
interface ProductsPageProps{
  params?: { products: string[] }
}

const ProductsPage = ({params}:ProductsPageProps) => {
  return(
    <div>
      <ul>
        {params?.products?.map(route => (
          <li>{route}</li>
        ))}
      </ul>
    </div>
  )
}
```




---------------------------------------------------------------------------------------




في هذا ال commit هنصمم ال login page ،
هنستخدم ال useState عشان ناخد القيمة الخاصية بال email وال password اللي هيكتبها ال user في ال login form ،
ولكن لأننا سنستخدم ال useState فإننا لابد من تحويل ال login page إلى client component بإستخدام use client ،

ولكن لأننا من الأفضل جعل الصفحات زي ماهي server component ، فيمكننا عمل component لل login form فقط ، ونخلي ال component ده client component ،
ونستورده في ال login page ، وبالتالي يمكننا إستخدام ال useState في ال form ، ونسيب صفحة ال login page كما هي server component ،
وبالتالي صفحة ال login page كالتالي : 

```tsx
import LoginForm from "./LoginForm";

const LoginPage = () => {
  return (
    <section className="h-[calc(100vh-100px)] container m-auto px-7 flex justify-center items-center">
      <div className="m-auto bg-white rounded-lg p-5 w-full md:w-2/3">
        <h1 className="text-3xl font-bold text-gray-800 mb-5">Log In</h1>
        <LoginForm/>
      </div>
    </section>
  )
}

export default LoginPage
```

وال LoginForm component كالتالي : 
```tsx
"use client";

import { useState } from "react";

const LoginForm = () => {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');

    const formSubmitHandler = (e:React.FormEvent) =>{
        e.preventDefault();
        console.log({email, password});
        
    }

    return (
        <form onSubmit={formSubmitHandler} className="flex flex-col">
            <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} className="mb-4 border rounded p-2 text-xl" placeholder="Enter Your Email"/>
            <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} className="mb-4 border rounded p-2 text-xl" placeholder="Enter Your Password"/>
            <button type="submit" className="text-2xl text-white bg-blue-800 p-2 rounded-lg font-bold">Login</button>
        </form>
    );
};

export default LoginForm;
```

ولاحظ أننا عملنا ال LoginForm component داخل فولدر ال login وليس في فولدر ال components كالمعتاد ، 
وذلك لأننا سنستخدمه فقط مع صفحة ال login ، وعادي برضه لو عملناه هناك مجرد مسألة تنظيمية حسب كل واحد .



ولكن في ال LoginForm component بالأعلى ، يمكن للمستخدم أن يدخل قيم فارغة ، ويعمل submit ، 
ولتفادي ذلك ، يمكننا استخدام if ، لو القيمة === "" فيرجع لنا رسالة ، كالتالي : 

```tsx
const formSubmitHandler = (e:React.FormEvent) =>{
        e.preventDefault();

        if(email === "") return console.log('Email Is Required');
        if(password === "") return console.log('Password Is Required');
        
        console.log({email, password});
        
    }
```

ولكن لعرض الرسائل بشكل جميل وأفضل ، سنستخدم مكتبة React-Toastify 
تجدها هنا :  https://fkhadra.github.io/react-toastify/introduction/ 

لتسطيب المكتبة : 
```
> npm install --save react-toastify
```

بعدها ، لابد من عمل import ل ToastContainer و toast وأيضاً import ل ReactToastify.css ، 
حيث سيتم عمل import ل ToastContainer و ReactToastify.css في ال layout الرئيسي ونستخدمه فيه ليكون متاح بكامل ال application كالتالي : 
```tsx
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import { ToastContainer } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';
import "./globals.css";
import Header from "@/components/header/Header";
import Footer from "@/components/Footer";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <Header />
        <ToastContainer />
        <main>
          {children}
        </main>
        <Footer />
      </body>
    </html>
  );
}
```

ثم بعد ذلك نعمل import ل toast في أي component نريد استخدام ال React Toast فيه ، ففي مثالنا ، سنستخدمه في ال LoginForm كالتالي : 

```tsx
"use client";

import { useState } from "react";
import { toast } from "react-toastify";

const LoginForm = () => {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');

    const formSubmitHandler = (e:React.FormEvent) =>{
        e.preventDefault();

        if(email === "") return toast.error('Email Is Required');
        if(password === "") return toast.error('Password Is Required');
        
        console.log({email, password});
        
    }

    return (
        <form onSubmit={formSubmitHandler} className="flex flex-col">
            <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} className="mb-4 border rounded p-2 text-xl" placeholder="Enter Your Email"/>
            <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} className="mb-4 border rounded p-2 text-xl" placeholder="Enter Your Password"/>
            <button type="submit" className="text-2xl text-white bg-blue-800 p-2 rounded-lg font-bold">Login</button>
        </form>
    );
};

export default LoginForm;
```

ولو عايزين يكون لونه غامق بدل الفاتح ، يعني في ال toast.error هيغلب عليه اللون الأحمر بدلاً من الخط الأحمر في التنبيه ،
فيمكننا ذلك بإضافة property باسم theme = colored في ال ToastContainer tag المستخدم بال layout كالتالي : 
```tsx
<ToastContainer theme="colored"/>
```
ولتغيير مكان التنبيه ، يمكن استخدام position = top-center مثلاً ، كالتالي : 
```tsx
<ToastContainer theme="colored" position="top-center"/>
``` 
أو bottom-left أو أي مكان حسب راحتنا ،




نقوم بعد ذلك بتصميم ال Register Page ، والتي ستكون مثل ال LoginPage وال LoginForm بالضبط مع إضافة حقل username ، 
فتكون صفحة ال Register كالتالي : 
```tsx
import RegisterForm from "./RegisterForm"
const RegisterPage = () => {
  return (
    <section className="h-[calc(100vh-100px)] container m-auto px-7 flex justify-center items-center">
      <div className="m-auto bg-white rounded-lg p-5 w-full md:w-2/3">
        <h1 className="text-3xl font-bold text-gray-800 mb-5">Create New Account</h1>
        <RegisterForm/>
      </div>
    </section>
  )
}

export default RegisterPage
```

ويكون ال RegisterForm كالتالي : 
```tsx
"use client";

import { useState } from "react";
import { toast } from "react-toastify";

const RegisterForm = () => {
    const [email, setEmail] = useState('');
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');

    const formSubmitHandler = (e:React.FormEvent) =>{
        e.preventDefault();

        if(email === "") return toast.error('Email Is Required');
        if(username === "") return toast.error('Username Is Required');
        if(password === "") return toast.error('Password Is Required');
        
        console.log({email, username, password});
        
    }

    return (
        <form onSubmit={formSubmitHandler} className="flex flex-col">
            <input type="text" value={username} onChange={(e) => setUsername(e.target.value)} className="mb-4 border rounded p-2 text-xl" placeholder="Enter Your Username"/>
            <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} className="mb-4 border rounded p-2 text-xl" placeholder="Enter Your Email"/>
            <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} className="mb-4 border rounded p-2 text-xl" placeholder="Enter Your Password"/>
            <button type="submit" className="text-2xl text-white bg-blue-800 p-2 rounded-lg font-bold">Register</button>
        </form>
    );
};

export default RegisterForm;
```





--------------------------------------------------------------------------




في هذا ال commit هنتكلم عن ال Caching ،
ال cache هو عبارة عن مخزن أو ذاكرة مؤقتة، 

ففي مثالنا الخاص ب articles ،
يقوم ال client بإرسال request إلى ال next.js server ،
فيقوم ال next.js server بإرسال طلب إلى ال API ، وهو ال jsonplaceholder ،
وبعدها سيأخذ ال articles من ال api ، ثم يتم وضع ال articles في ال next.js server في ال ArticlesPage ، ثم يرسل ال respone لل client 

ولكن لابد من العلم بأن ال next.js عندها data cache system لتخزين البيانات ، حيث يقوم ال next.js server بتخزين البيانات المستلمة من ال API في تلك ال data cache system ،

وهذا يفيد جداً في التالي : 
لنفترض أن بعد 3 ايام قام ال client بفتح ال Articles Page ، فسيقوم ال next.js server بإستدعاء البيانات من ال cache مباشرة وإرسالها لل client ، بدلاً من إرسال request اخر لل API ،
مما يوفر الكثير من الوقت ، والجهد على ال API server .

ولكن لو بيانات ال API تتغير كل 10 ثواني مثلاً ، فلن يصلح هذا ال cache ، وبالتالي نعمل لها disable ، 
حيث يتم تعطيل ال cache من خلال إضافة cache : no-store في دالة ال fetch كالتالي : 
```tsx
const response = await fetch("https://jsonplaceholder.typicode.com/posts", {cache: 'no-store'});
```
القيمة الافتراضية هي force-cache ، 


ولكن قد تتغير البيانات كل 50 ثانية ، ونريد أن يقوم ال Next.js Server بعمل refresh للبيانات كل 50 ثانية ، كالتالي : 
```tsx
const response = await fetch("https://jsonplaceholder.typicode.com/posts", {next:{revalidate: 50}});
```
يمكنك كتابة أي قيمة في ال revalidate ، ولكن خليك عارف أن القيمة بالثواني .







------------------------------------------------------------------------------------







في هذا ال commit هنتكلم عن فولدر next.
وهو فولدر سيكون موجود في أي مشروع next.js ، وهو يعتبر المنتج النهائي للمشروع ، ويعتبر هو ال production folder ،
بمعني أن بيئة التطوير هي فولدر src و public وهكذا ، ولكن يقوم next.js بعمل بعض العمليات على ملفات بيئة التطوير development enviroment ، ثم يجعل الكود النهائي في فولدر .next ،

حيث أن هذا الفولدر .next هو الفولدر النهائي الذي يتم رفعه على الإستضافة ،
ولكن لابد أن يتم عمل build له أولاً قبل أخذه ورفعه للإستضافة ، وذلك ليكون جاهز بكل تحديثات الأكواد ،
ولعمل build بالأمر التالي : 
```
> npm run build
```
وستأخذ العملية بعض الوقت حسب حجم المشروع لتحديث فولدر .next ،

ولكن حالياً أنا لست رافع المشروع على ال host ، 
وفي نفس الوقت أريد أن اري المنتج النهائي بالمتصفح ، وذلك من خلال الأمر 
```
> npm start
```

حيث أن npm run dev يقوم بتشغيل المشروع من بيئة التطوير ، و npm run start يقوم بتشغيل المشروع من بيئة ال production 
وهذا يفيدنا في فحص المشروع قبل عمل deploy له على ال remote host .




----------------------------------------------------------------------------------------




في هذا ال Commit هنتكلم عن ال Rendering 
ال rendering هو بناء صفحات الويب ،
بمعنى بناء صفحات ال html ،
ومع كل صفحة html توجد ملفات css و javascript وأيضاً صور و fonts وملفات ، ...
ولكن الأساس هو ال html وهذا هو ال rendering 

عندنا نوعين من ال rendering  :
Pre-rendering ( At Server )   &   Client-Side Rendering (CSR)



**Client-Side Rendering (CSR)**

ال Client-side rendering هو الأسلوب الموجود في react.js ،
وهو أنه يتم بناء صفحات ال html في المتصفح ، بمعني أن المتصفح هو اللي بيعمل rendering ،
فهو عامل زي ال function اللي كنا بنعملها بال jquery و ajax كده ، كنا عند event معين يتم اضافة كود ما ، 
مثلاً في جدول ، اضغط على زر اضافة فيقوم ببناء tr جديد ، وممكن يكون ال component اللي هيتم بناءه أكبر ، وكان ممكن يتم بناءه مع تحميل الصفحة ، 
في react.js نفس الكلام ، بيكون عندي الصفحة فاضية html ، وبيتم تحميل ال components كلها فيه ، 
وبالتالي لو دخلنا على ال view-source لأي موقع معمول بال react.js هنلاقي ملف ال html فاضي ، وبالتالي بيكون سئ جداً في ال SEO أي محركات البحث ،

ففي react.js فال client يرسل request لل website ،
فيقوم ال backend بإعطاء ال client كل التطبيق في ال response ، وكل التطبيق يكون موجود فيه ملف فاضي html وملف bundle.js واللي هيكون فيه ال components بال javascript ،
وبعدها سيأخذ المتصفح هذه الملفات ويفتح ملف ال html واللي هيكون فاضي ، بعد كده هيبدأ يفتح ملف ال js وينفذ اللي فيه ويتم بناء ال components اللي فيه داخل التطبيق ، 

ويكون عندنا مشكلتين ، مشكلة أن ال load هيكون بطئ ، المشكلة التانية أن الموقع هيكون غير صديق لمحركات البحث SEO ،




**Pre-rendering ( At Server )**

في Next.js الموضوع مختلف فيستخدم أسلوب ال Pre-rendering (At Server) ، فيتم بناء صفحات ال html في ال server ، ثم يقوم ال server ببناء هذه الصفحة للمتصفح ،
والمتصفح يقوم فقط بقراءة الملف ، 

وفي Next.js عندنا نوعين من ال Rendering : 
Static-Site Generation ( SSG )   &   Server-Side Rendering ( SSR )

ال Static-Site Generation (SSG) ده بيتم بناء الصفحات خلال ال  build time للمشروع ، بمعنى مع إعطاء الأمر npm run build ، واللي بنكون فيه بنجهز ملفات المشروع النهائية لرفعه عال Host ،
فعند هذا الأمر يقوم next.js ببناء كل الصفحات وتخزينها في فولدر ال .next ،

وهذه الصفحات بالتالي ستكون جاهزة ويتم إرسالها لل browser مباشرة وتكون سريعة ، وبالأخص أن الصفحات دي هتكون Static وليست Dynamic ، أي أن البيانات ستكون ثابتة .


ال Server-Side Rendering (SSR) ، يتم ذلك للصفحات اللي فيها بيانات متغيرة ، 
بمعنى أن المستخدم هيبعت request لل server ، فإن ال next.js هيجيب ال response ويركبه على ملف ال html ويرسل الملف لل browser ،
بمعنى إن ملف ال html مش هيكون جاهز ، فحسب طلب المستخدم هيتم بناء الصفحة وإرسالها لل Browser ، 
وده بتنفع في الصفحات اللي بتتغير علطول ، زي صفحة posts/[id]/page.tsx ، فال page هيكون فيها بيانات بتحتلف حسب ال post اللي المستخدم هيفتحه ،


فلو في المشروع عملنا الأمر npm run build ، هيطلعلنا النتيجة زي كده مثلاً : 

```
Route (app)                              Size     First Load JS
┌ ○ /                                    5.58 kB        89.8 kB
├ ○ /_not-found                          0 B                0 B
├ ○ /about                               147 B          84.3 kB
├ ○ /admin                               147 B          84.3 kB
├ ○ /articles                            178 B          91.1 kB
├ λ /articles/[id]                       147 B          84.3 kB
├ ○ /articles/search                     147 B          84.3 kB
├ ○ /login                               552 B          91.1 kB
└ ○ /register                            588 B          91.1 kB
+ First Load JS shared by all            84.2 kB
  ├ chunks/69-9c3c64001cadfd4c.js        28.9 kB
  ├ chunks/fd9d1056-534a3af521b04580.js  53.4 kB
  └ other shared chunks (total)          1.9 kB


○  (Static)   prerendered as static content
λ  (Dynamic)  server-rendered on demand using Node.js
```

بمعنى أنه تم بناء المشروع وتجهيزه ، وعندنا نوعين من الصفحات  : 
نوع Static بالرمز ○ ، ونوع Dynamic بالرمز λ ، 
بمعنى أن ال Static هيتم عمل Static-Site Generation لها ، 
أما ال Dynamic هيتم عمل Server-Side Rendering لها ،

ولو دخل على الملفات بالمشروع في المسار : 
.next/server/app
هنلاقي تم عمل html generation للملفات ال static ، مثل about.html ، admin.html وهكذا ...

ولن نجد ملف لصفحة articles/[id] لأن بيانات هذه الصفحة ستتغير حسب طلب كل مستخدم ، 
فيتم بناء هذه الصفحة كالتالي : المستخدم بيرسل request لل next.js server ، ال server بياخد ال id ويرسله لل api ، ثم ياخد البيانات من ال api ويحطها بال component ثم يبني ملف ال html ويرسله بعد ذلك لل Browser ليتم عرضه للمستخدم بالنهاية.


وفي النهاية عشان تكون واضحة ،
لو عندي صفحة posts/page.tsx واللي بيتم فيها عرض كل ال posts ،
ولما بنضغط علي post معين منهم بيوديني للصفحة posts/[id]/page.tsx ،

فإن صفحة ال posts/page.tsx هي صفحة Static لأنه لا يتم تغيير البيانات حسب الطلب ، فعند زيارة المستخدم لهذه الصفحة يتم جلب البيانات من ال api ووضعها بال component وارسال ال html للمتصفح ،

أما صفحة posts/[id]/page.tsx فتكون صفحة dynamic مش معروف أي post هيفتحه ال user .








-------------------------------------------------------------------------------------------







سنقوم في هذا ال commit بتصميم ال Admin Dashboard ،
فداخل فولدر app/admin نقوم بإنشاء الفولدرات التالية ، والتي تمثل مسار لكل فولدر كالتالي :
app/admin/articles-table/page.tsx
app/admin/comments-table/page.tsx

نريد عمل Sidebar وتكون موجودة في ال sub-pages of admin بمعني كل الصفحات الموجودة داخل ال Admin

فممكن نعمل component لل sidebar ونستورده في صفحات ال admin اللي احنا عايزينها ، 
ولكن الأفضل اننا نعمل layout مخصص لل admin ، عن طريق إنشاء ملف بإسم layout.tsx ولايمكن بأي اسم غير layout ،

ومن خلال ال children هنحدد مكان ال Children داخل ال layout ، ويفضل لو نعمل interface ليكون كالتالي : 
```tsx
interface AdminDashbourdLayoutProps{
    children : React.ReactNode;
}
const AdminDashbourdLayout = ({children} : AdminDashbourdLayoutProps) => {
  return (
    <div>
        <div>Admin SideBar</div>
        <div>{children}</div>
    </div>
  )
}

export default AdminDashbourdLayout
```

نقوم بإنشاء Component للـ AdminSidebar واستيراده داخل ال layout ، 
ليكون كود ال Layout كالتالي : 
```tsx
import AdminSidebar from "./AdminSidebar";


interface AdminDashbourdLayoutProps{
    children : React.ReactNode;
}
const AdminDashbourdLayout = ({children} : AdminDashbourdLayoutProps) => {
  return (
    <div className="h-[calc(100vh-150px)] flex items-start justify-between overflow-hidden">
        <div className="h-[calc(100vh-150px)] w-15 lg:w-1/5 bg-purple-600 text-white p-1 lg:p-5 ">
            <AdminSidebar/>
        </div>
        <div className="h-[calc(100vh-150px)] w-full lg:w-4/5 overflow-y-scroll">
            {children}
        </div>
    </div>
  )
}

export default AdminDashbourdLayout
```

وكود ال AdminSidebar كالتالي : 
```tsx
import Link from "next/link"
import { CgMenuGridR } from 'react-icons/cg';
import { MdOutlineArticle } from 'react-icons/md';
import { FaRegComments } from 'react-icons/fa';

const AdminSidebar = () => {
  return (
    <>
        <Link href="/admin" className="flex items-center text-lg lg:text-2xl font-semibold">
            <CgMenuGridR className="text-3xl me-1"/>
            <span className="hidden lg:block">Dashboard</span>
        </Link>

        <ul className="flex justify-center items-center flex-col lg:items-start mt-10">
            <Link href="/admin/articles-table" className="flex items-center text-lx mb-5 lg:border-b border-gray-300 hover:border-yellow-200 hover:text-yellow-200 transition">
                <MdOutlineArticle className="me-1"/>
                <span className="hidden lg:block">Articles</span>
            </Link>
            <Link href="/admin/comments-table" className="flex items-center text-lx mb-5 lg:border-b border-gray-300 hover:border-yellow-200 hover:text-yellow-200 transition">
                <FaRegComments className="me-1"/>
                <span className="hidden lg:block">Comments</span>
            </Link>
        </ul>
    </>
  )
}

export default AdminSidebar
```



نقوم الآن بعمل تصميم لصفحات ال admin ،

فنقوم بإنشاء AddArticleForm component كالتالي : 
```tsx
"use client";

import { useState } from "react";
import { toast } from "react-toastify";

const AddArticleForm = () => {
    const [title, setTitle] = useState('');
    const [description, setDescription] = useState('');

    const formSubmitHandler = (e:React.FormEvent) =>{
        e.preventDefault();

        if(title === "") return toast.error('Title Is Required');
        if(description === "") return toast.error('Description Is Required');
        
        console.log({title, description});
        
    }

    return (
        <form onSubmit={formSubmitHandler} className="flex flex-col">
            <input type="text" value={title} onChange={(e) => setTitle(e.target.value)} className="mb-4 border rounded p-2 text-xl" placeholder="Enter Article Title"/>
            <textarea value={description} onChange={(e) => setDescription(e.target.value)} className="mb-4 p-2 lg:text-xl rounded resize-none" rows={5} placeholder="Enter Article Discription" ></textarea>
            <button type="submit" className="text-2xl text-white bg-blue-700 p-2 rounded-lg font-bold hover:bg-blue-900">Add</button>
        </form>
    );
};

export default AddArticleForm;
```

ونعمل استيراد لل component داخل ال page الخاصة بال admin لتكون كالتالي : 
```tsx
import AddArticleForm from "./AddArticleForm"

const AdminPage = () => {
  return (
    <div className="h-[calc(100vh-150px)] flex justify-center items-center px-5 lg:px-20">
      <div className="shadow p-4 bg-purple-200 rounded w-full">
        <h2 className="text-xl lg:text-2xl text-gray-700 font-semibold mb-4">
          Add New Article
        </h2>
        <AddArticleForm/>
      </div>
    </div>
  )
}

export default AdminPage
```





------------------------------------------------------------------------------------------






مكتبة ال react.js تستخدم ال Client-Side rendering ،
وال Next.js يستخدم ال Pre-rendering لبناء صفحات الويب ،

فلرؤية هذا فعلياً بالمتصفح سيكون كالتالي : 
افتح مشروع ال react.js بالمتصفح ، ثم : 
right click -> inspect -> network 
choose all types 
Then reload the page 
هيبع request لل server ، وال server هيبعت ال response ،
والذي سيحتوي على كل الملفات اللي جاية من ال server ومن ضمنهم ملف ال html وال bundle.js والذي يحتوي على كل تطبيق ال react.js ،

فلو فتحنا ملف ال html هنلاقي كود ال html فارغ ، 
بمعنى أن المتصفح يفتح html وبعد ذلك يبني المشروع من خلال دمج ال components الموجودة بال bundle.js داخل ملف ال html في ال 
```tsx
<div id='root'></div>
```

أما في ال Next.js فلو فتحنا ملف ال html سنجد أنه يحتوى على كل أكواد الصفحة .


لتغيير ال Page Title لأي صفحة ،
ممكن من خلال ال metadata في ال layout وكذلك ال description ، 
فلازم أولاً نعمل import لل Metadata ثم نستخدمه كالتالي : 
```tsx
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};
```

وبالتالي كل ال nested routs الخاصة بهذا ال layout سيأخذون هذا ال title وال description ،
فلو عملناها في ال admin layout سيكون كالتالي : 

```tsx
import type { Metadata } from "next";

export const metadata:Metadata = {
  title: "Admin Dashboard",
  description: "This is Admin Dashboard",
}
```

ولو عايزين نعمل ال Metadata لصفحة معينة داخل ال admin ، بمعني أن نخصص title و description لكل صفحة لوحدها ،
فممكن داخل ال ArticlesPage نقوم بالتالي : 
```tsx
import { Metadata } from "next";

export const metadata:Metadata = {
  title: "Articles Page",
  description: "Articles About Programming",
}
```
وال description مهم لمحركات البحث ، عشان يعرفوا أن الصفحة دي تخص موضوع معين فيكون في الصدارة .




-----------------------------------------------------------------------------------





في هذا ال commit عايزين نصمم ال articles page ،
فسيتكون عندنا من 3 أقسام ، 

**القسم الأول هو ال Search Block**

في ال src/components/articles نقوم بإنشاء component بإسم SearchArticleInput.tsx 
والذي سيكون form وممكن نسخ ال login form فيه والتعديل عليه ، ليكون الكود كالتالي : 
```tsx
"use client";

import { useState } from "react";

const SearchArticleInput = () => {
    const [searchText, setSearchText] = useState('');

    const formSubmitHandler = (e:React.FormEvent) =>{
        e.preventDefault();

        console.log({searchText});
        
    }

    return (
        <form onSubmit={formSubmitHandler} className="my-5 w-full md:w-2/3 m-auto">
            <input type="search" value={searchText} onChange={(e) => setSearchText(e.target.value)} className="w-full p-3 rounded text-xl border-none text-gray-900" placeholder="Search For Article"/>
        </form>
    );
};

export default SearchArticleInput;
```

ويتم عمل import لها بال Articles page كالتالي : 
```tsx
import ArticleItem from "@/components/articles/ArticleItem";
import SearchArticleInput from "@/components/articles/SearchArticleInput";
import { Article } from "@/utils/types";
import { Metadata } from "next";

export const metadata:Metadata = {
  title: "Articles Page",
  description: "Articles About Programming",
}

const ArticlesPage = async () => {
  const response = await fetch("https://jsonplaceholder.typicode.com/posts");

  if(!response.ok){
    throw new Error("Failed To Fetch Articles");
  }

  const articles: Article[] = await response.json();

  return (
    <section className="container m-auto px-5">
      <SearchArticleInput/>
      <div className="flex items-center justify-center flex-wrap gap-7">
        {articles.map((item) => (
          <ArticleItem article={item} key={item.id} />
        ))}
      </div>
    </section>
  );
};

export default ArticlesPage;
```


**القسم الثاني هو ال Articles** 

**القسم الثالث هو ال Pagination** 

عايزين نعمل pagination لصفحة ال articles ،
أولاً نريد عرض 6 articles فقط بالصفحة ، 
يتم ذلك من خلال ال slice method قبل أن يتم عمل map كالتالي : 
```tsx
<div className="flex items-center justify-center flex-wrap gap-7">
        {articles.slice(0, 6).map((item) => (
          <ArticleItem article={item} key={item.id} />
        ))}
      </div>
```


يتم عمل Pagination component في ال src/components/articles  ليكون كالتالي : 
```tsx
const pages = [1, 2, 3, 4]

const Pagination = () => {
  return (
    <div className='flex justify-center items-center mt-2 mb-10'>
        <div className="border border-gray-700 text-gray-700 py-1 px-3 font-bold text-xl cursor-pointer hover:bg-gray-200 transition">
            Prev
        </div>
        {pages.map(item=>
        <div key={item} className="border border-gray-700 text-gray-700 py-1 px-3 font-bold text-xl cursor-pointer hover:bg-gray-200 transition">
            {item}
        </div>
        )}
        <div className="border border-gray-700 text-gray-700 py-1 px-3 font-bold text-xl cursor-pointer hover:bg-gray-200 transition">
            Next
        </div>
    </div>
  )
}

export default Pagination
```

ثم يتم استيراده في ال articles page ، كالتالي : 
```tsx
return (
    <section className="container m-auto px-5">
      <SearchArticleInput/>
      <div className="flex items-center justify-center flex-wrap gap-7">
        {articles.slice(0, 6).map((item) => (
          <ArticleItem article={item} key={item.id} />
        ))}
      </div>
      <Pagination/>
    </section>
  );
```



عايزين في ال Single Article Page نعمل Form لل comments على هذا ال article ،
فنقوم بإنشاء فولدر comments داخل ال components ، ونقوم فيه بإنشاء component بإسم AddCommentForm.tsx ، ليكون كالتالي : 
```tsx
"use client";
import { useState } from "react";
import { toast } from "react-toastify";

const AddCommentForm = () => {
    const [text, setText] = useState('');

    const formSubmitHandler = (e:React.FormEvent) =>{
        e.preventDefault();
        if(text === '') return toast.error('Please Write Something');
        console.log({setText});
    }

    return (
        <form onSubmit={formSubmitHandler}>
            <input type="text" value={text} onChange={(e) => setText(e.target.value)} className="w-full p-2 rounded-lg text-xl border-none bg-white focus:shadow-md" placeholder="Add Comment"/>
            <button type="submit" className="bg-green-700 text-white mt-2 p-1 w-min text-xl rounded-lg hover:bg-green-900 transition">
                Comment
            </button>
        </form>
    );
};

export default AddCommentForm;
```



نقوم أيضاً بإنشاء component يقوم بعرض ال comments اسفل ال Article وال Add Comment component ، بإسم CommentItem.tsx ، كالتالي : 
```tsx
import { FaEdit, FaTrash } from "react-icons/fa"

const CommentItem = () => {
  return (
    <div className="mb-5 rounded-lg p-3 bg-gray-200 border-2 border-gray-300">
        <div className="flex justify-between items-center mb-2">
            <strong className="text-gray-800 uppercase">
                Sakr
            </strong>
            <span className="bg-yellow-700 px-1 rounded-lg text-white">
                1/1/2024
            </span>
        </div>
        <p className="text-gray-800 mb-2">
            Thanks For This Article
        </p>
        <div className="flex justify-end items-center">
            <FaEdit className="text-green-600 text-xl cursor-pointer me-3"/>
            <FaTrash className="text-red-600 text-xl cursor-pointer"/>
        </div>
    </div>
  )
}

export default CommentItem
```

ويتم إستيراده في ال Single Article page كالتالي : 

```tsx
import AddCommentForm from "@/components/comments/AddCommentForm";
import CommentItem from "@/components/comments/CommentItem";
import { Article } from "@/utils/types";

interface SingleArticelPageProps{
    params:{ id:string }
}

const SingleArticelPage = async ({params}:SingleArticelPageProps) => {
    const response = await fetch(`https://jsonplaceholder.typicode.com/posts/${params.id}`);
    if(!response.ok){
        throw new Error('Failed To Fetch Article Details');
    }
    const article: Article = await response.json();

  return (
    <section className="min-h-[calc(100vh-150px)] container m-auto w-full px-5 pt-8 md:w-3/4">
        <div className="bg-white p-7 rounded-lg mb-7">
            <h1 className="text-3xl font-bold text-gray-700 mb-2">{article.title}</h1>
            <div className="text-gray-400">1/1/2024</div>
            <p className="text-gray-800 text-xl mt-5">{article.body}</p>
        </div>
        
        <AddCommentForm/>

        <h4 className="text-xl text-gray-800 ps-1 font-semibold mb-2 mt-7">
            Comments
        </h4>

        <CommentItem/>
        <CommentItem/>
        <CommentItem/>
    </section>
  )
}

export default SingleArticelPage
```





--------------------------------------------------------------------------------------------------------







سنقوم في هذا ال commit بعمل loading ،
فبعض الأوقات عند التقلب بين الصفحات ، نجد أنه قد يأخذ ثواني لفتح الصفحة الجديدة ، فممكن أن نعمل component يظهر عن تحميل الصفحة كعلامة على الإنتظار ، 
ويتم ذلك في Next.js بكل سهولة ، مجرد إنشاء ملف بإسم loading.tsx في ال top level أي في ال app مباشرة ، ولاحظ أنه لا يمكن أن يكون إسم الصفحة بأي اسم اخر ، 

ويمكن أن يتم عمل ال loading page كالتالي : 
```tsx
const loading = () => {
  return (
    <div className="h-[calc(100vh-150px)] flex justify-center items-center">
        <div>Loading ... </div>
    </div>
  )
}

export default loading
```

ولكن ممكن منلحقش نشوف تنفيذ ال loading لأن الصفحة اللي بنفتحها بتفتح بسرعة ، 
وبالتالي ممكن لإختبار ال loading فقط نكتب كود لتأخير صفحة مثل صفحة ال articles للإختبار فقط ، 
الكود كالتالي : 
```tsx
await new Promise((resolve) => setTimeout(resolve, 10000));
```

وهذا يعني أنه سيتم تأخير تنفيذ الأكواد التالية لمدة 10 ثواني ،
حيث سيتم كتابة هذا الكود في بداية ال function component بداخله ، وطبعاً مادام هنستخدم await يبقى هتكون مضطر تخلي ال function component تاخد async



ولو عايزين نخصص component مختلف لكل صفحة ، يتم ذلك من خلال إنشاء ملف بنفس الاسم loading.tsx داخل فولدر هذه الصفحة ، 


فلتصميم ايقونة لل loading ، ممكن من خلال صورة مثلاً أو من أي مكتبة tailwind css كـ flowbite.com هنلاقيها باسم spinner ، 

وممكن كمان نستخدم skeleton وهو اننا نصمم boxes على نفس حجم ال elements الموجودة بالصفحة اللي هنعمل فيها ال loading وذلك من خلال أخذ ال classes بالصفحة وحذف ال classes الغير مطلوبة وحذف اي background classes واستخدام class مثل bg-gray-300 للون خلفية رمادي ، و class بإسم animate-pulse واللي هيعمل اضاءة متحركة للون الخلفية ، 

وعشان ال elements دي هتكون فارغة بدون محتوى ، فلازم نديها height مناسب لكل element ،

وطبعاً لو عندك component متكرر في الصفحة اللي بنعمل لها loading ممكن نعمل array ونستخدم ال map للتكرار ، فمثلاً صفحة articles هتعرض 6 articles بها ، 
سيكون الكود كالتالي : 

```tsx
const articles = [1, 2, 3, 4, 5, 6];

const loading = () => {
  return (
    <section className="container m-auto px-5 animate-pulse">
        <div className="bg-gray-300 animate-pulse h-12 my-5 w-full md:w-2/3 m-auto"></div>

        <div className="flex items-center justify-center flex-wrap gap-7">
            {articles.map((article)=>(
                <div key={article} className="bg-gray-200 p-5 rounded-lg my-1 w-full md:w-2/5 lg:w-1/4">
                    <h3 className=" bg-gray-300 h-6"></h3>
                    <p className="my-2  bg-gray-300 h-10 p-1"></p>
                    <div className="bg-gray-400 h-8 w-full block text-center rounded-lg"></div>
                </div>
            ))}
            
        </div>
      
      {/* Pagination */}
      <div className="flex justify-center items-center mt-2 mb-10">
        <div className='bg-gray-300 animate-pulse h-9 rounded-sm w-[300px] mt-2 mb-10'></div>
      </div>

    </section>
  )
}

export default loading
```




--------------------------------------------------------------------------------------------




سنتكلم في هذا ال commit عن ال Navigation ،
فلما بضغط على link ال aricles بيوديني على صفحة ال articles ،
ولما اضغط على login ، بيوديني على صفحة ال login ، 

فعملية التوجيه هنا هي ال navigation ، 
فمثلاً عايز في صفحة ال login لما اضغط على زر login يتم تحويلي على ال Home page أو ال Profile ،


عندنا hook في Next.js يسمى useRouter ، يتم عمل import له من ال next/navigation ، وليس من next/router ، كالتالي : 
```tsx
import { useRouter } from "next/navigation";
```
وخد بالك هتستخدم ال 'use client' ، 

هنعمل const كالتالي : 
```tsx
const router = useRouter();
```
ثم بعد ذلك هنستخدم ال const router في ال method الخاصة بال submit ، بمعنى في حالة نجاح ال response هيتم تحويل المستخدم لمسار كذا ،
وذلك أيضاً بإستخدام إما replace() function أو push() function كالتالي : 
```tsx
"use client";

import { useState } from "react";
import { toast } from "react-toastify";
import { useRouter } from "next/navigation";

const LoginForm = () => {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');

    const router = useRouter();

    const formSubmitHandler = (e:React.FormEvent) =>{
        e.preventDefault();

        if(email === "") return toast.error('Email Is Required');
        if(password === "") return toast.error('Password Is Required');
        
        console.log({email, password});
        router.replace('/');
    }

    return (
        <form onSubmit={formSubmitHandler} className="flex flex-col">
            <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} className="mb-4 border rounded p-2 text-xl" placeholder="Enter Your Email"/>
            <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} className="mb-4 border rounded p-2 text-xl" placeholder="Enter Your Password"/>
            <button type="submit" className="text-2xl text-white bg-blue-800 p-2 rounded-lg font-bold">Login</button>
        </form>
    );
};

export default LoginForm;
```

عندنا أكثر من methods يمكن إستخدامهم مع ال useRouter ، 
فال replace() method : يقوم بتوجيه المستخدم لمسار معين ، مع تجنب اضافة صفحة ال login إلى ال history stack ، بمعنى لا يمكن للمستخدم الرجوع للصفحة السابقة ،
أما ال push() method : فبالظبط هي ال replace ، ولكن تقوم بإضافة آخر صفحة والتي بها ال function لل history stack .
ال back() method : تقوم بالرجوع للصفحة السابقة .
ال back() method : تقوم بالرجوع للصفحة السابقة .
ويوجد أيضاً prefetch() method : وهي تقوم بتحضير محتوى صفحة من المتوقع بدرجة كبيرة أن المستخدم سيقوم بزيارتها من خلال الصفحة الحالية ،
فلتوفير الوقت ولجعل الأداء أعلى ، يمكننا إستخدام prefetch لجلب محتوى الصفحة مسبقاً ، وخد بالك سيجلب المحتوى الثابت ولن يجلب البيانات من قاعدة البيانات لو الصفحة المستهدفة تحتوى على بيانات من ال database ، 
فحسب استفسار من ChatGPT النقاش كالتالي : 

### ------------------------------------------------------------------- ChatGPT - Start 01
**أنا** : ممكن تشرحلي router.prefetch في next.js
**الروبوت** : بالطبع! في Next.js، يُستخدم خاصية router.prefetch لتحسين أداء التنقل بين الصفحات. تقوم هذه الخاصية بتحميل الصفحة التي ستتم زيارتها في المستقبل مسبقًا (من هنا جاءت التسمية "prefetch")، بدلاً من انتظار الضغط على الرابط وتحميل الصفحة عند الحاجة.

عندما تقوم بتضمين router.prefetch في رمز التطبيق الخاص بك، سيقوم Next.js بتحميل الصفحة المستهدفة وجميع الملفات المرتبطة بها (مثل ملفات الأسلوب والصور) مسبقًا. هذا يعني أنه عندما يقوم المستخدم بالضغط على الرابط، ستكون الصفحة متاحة فورًا بدون أي تأخير قابل للملاحظة.

يمكنك استخدام router.prefetch في أي رابط يستخدمه التطبيق، سواء كان ذلك في قوائم التنقل أو في أي مكان آخر. على سبيل المثال، يمكنك استخدامه في رمز JSX كالتالي:
```tsx
import Link from 'next/link';
import { useEffect } from 'react';
import { useRouter } from 'next/router';

const HomePage = () => {
  const router = useRouter();

  useEffect(() => {
    // تحميل الصفحة المستهدفة وجميع الملفات المرتبطة بها مسبقًا
    router.prefetch('/about');
  }, []);

  return (
    <div>
      <h1>الصفحة الرئيسية</h1>
      <Link href="/about">
        <a>اذهب إلى صفحة المعلومات</a>
      </Link>
    </div>
  );
};

export default HomePage;
```

في المثال أعلاه، تم استيراد Link من Next.js لتوفير رابط التنقل، واستيراد useEffect و useRouter من React Hooks. في داخل useEffect، يتم استخدام router.prefetch لتحميل صفحة /about مسبقًا.

بهذه الطريقة، عندما يتم عرض الصفحة الرئيسية، سيتم تحميل صفحة المعلومات مسبقًا تحسبًا للانتقال المستقبلي إليها. هذا يزيد من سرعة التنقل في التطبيق ويحسن تجربة المستخدم عند الانتقال بين الصفحات.

**أنا** : ولكن ماذا لو الصفحة التي سيتم تحميلها مسبقاً تعتمد على جلب بيانات من قاعدة البيانات ، هل سيقوم بتحضير تلك البيانات أيضاً قبل الضغط على link الدخول للصفحة ؟

**الروبوت** : عند استخدام router.prefetch في Next.js، فإنه يتم تحميل الملفات المرتبطة بالصفحة مسبقًا، ولكنه لا يقوم بتنفيذ أي طلبات لاسترجاع البيانات من قاعدة البيانات أو أي خدمة أخرى.

إذا كانت الصفحة التي تريد تحميلها مسبقًا تعتمد على جلب البيانات من قاعدة البيانات، فيمكنك استخدام مفهوم التحميل المؤجل (Lazy Loading) لتأجيل جلب البيانات حتى يتم فعليًا الانتقال إلى الصفحة.

يمكنك استخدام مكتبة مثل react-query أو swr لإدارة عمليات جلب البيانات بشكل فعال ومؤجل. هذه المكتبات توفر طرقًا سهلة لإجراء الطلبات إلى الخادم وتخزين البيانات المسترجعة للاستفادة منها في أجزاء مختلفة من التطبيق.

عند استخدام مفهوم التحميل المؤجل، يمكنك استخدام router.prefetch لتحميل ملفات الصفحة مسبقًا وتجهيز الواجهة الأمامية، بينما تستخدم مكتبة إدارة الحالة (مثل react-query) لتنفيذ الطلبات وجلب البيانات الفعلية عند الانتقال إلى الصفحة.

هذا النهج يسمح بتحقيق أداء متفوق للتطبيق وتقديم تجربة استخدام سلسة للمستخدم، حيث لا يحتاج المستخدم إلى الانتظار لفترة زمنية طويلة لجلب البيانات قبل رؤية الصفحة.

### -------------------------------------------------------------------------- ChatGPT - End 01

ويوجد methods أخري تستخدم مع ال router مثل reload ، events ، beforePropState 




عايزين دلوقتى لما المستخدم يدخل على صفحة ال articles ، ويكتب أي شئ في ال SearchArticleInput تقوم ال js بالبحث عن ذلك الشئ ثم يفتح صفحة articles/search/page ، وعرض بيانات ال article في ال search page ،
وبالتالي هنستورد useRouter في ال SearchArticleInput component لإستخدامها في ال formSubmitHandler ، كالتالي : 
```tsx
"use client";

import { useRouter } from "next/navigation";
import { useState } from "react";

const SearchArticleInput = () => {
    const [searchText, setSearchText] = useState('');
    const router = useRouter();

    const formSubmitHandler = (e:React.FormEvent) =>{
        e.preventDefault();

        console.log({searchText});
        router.push('/articles/search');
    }

    return (
        <form onSubmit={formSubmitHandler} className="my-5 w-full md:w-2/3 m-auto">
            <input type="search" value={searchText} onChange={(e) => setSearchText(e.target.value)} className="w-full p-3 rounded text-xl border-none text-gray-900" placeholder="Search For Article"/>
        </form>
    );
};

export default SearchArticleInput;
```

ولكننا سنحتاج النص اللي المستخدم هيكتبه في ال search input لإستخدامه في صفحة ال articles/search/page ، فكيف يتم جلب هذا النص ، 
يتم ذلك بإستخدام ال query string ، فيتم أولاً إضافة ال query string للمسار المطلوب التوجيه له ، كالتالي : 
```tsx
router.push(`/articles/search?text=${searchText}`);
```
ثم بعد ذلك نذهب للصفحة المستهدفة واللي هنستخدم ال query string بها ، لإستخدامه كالتالي : 
```tsx
const ArticlesSearchPage = (props:any) => {
  console.log(props);
  
  return (
    <div>ArticlesSearchPage</div>
  )
}

export default ArticlesSearchPage
```

سيتم عرض النتيجة كالتالي : 
```
{ params: {}, searchParams: { text: 'صقر' } }
```

نقوم بإستخدام ال interface لتحسين الكود كالتالي : 
```tsx
interface ArticlesSearchPageProps{
  searchParams:{text: string},
}

const ArticlesSearchPage = ({searchParams}:ArticlesSearchPageProps) => {  
  return (
    <section className="flex justify-center p-5 m-5">
      <h1 className="font-bold mx-2">Search Text Is: </h1>
      <p>{searchParams.text}</p>
    </section>
  )
}

export default ArticlesSearchPage
```



### -------------------------------------------------------------------------- ChatGPT - Start 02
**أنا** : ما اهمية ال interface في هذا الكود ولماذا تم إستخدامها ؟
**الروبوت** : الـ interface في الكود الذي قدمته يستخدم لتعريف نوع البيانات المتوقعة لخاصية searchParams في ArticlesSearchPage.

باستخدام الـ interface، يتم تحديد هيكل البيانات المتوقعة للكائن searchParams، وبالتحديد يحتوي على خاصية text من نوع string. هذا يوفر إرشادًا للمطورين الآخرين حول كيفية استخدام هذه الخاصية والنوع المتوقع للقيمة التي ستتم تمريرها إليها.

عند تعريف الـ interface، يتم توثيق الهيكل المتوقع للبيانات، مما يسهل على المطورين قراءة وفهم الكود وتحليل كيفية تداخل العناصر والبيانات.

في المثال المقدم، الـ interface تساعد في توضيح أن الصفحة ArticlesSearchPage تستقبل خاصية searchParams التي يتوقع أن تحتوي على خاصية text من نوع string. وبالتالي، يتم استخدام قيمة searchParams.text في عرض النص المرتبط بعنصر p.

باستخدام الـ interface، يمكن للمطورين فهم بنية البيانات المتوقعة للكائنات وتحديد الأنواع المناسبة لكل خاصية، مما يساعد في تحسين صيانة الكود وتعزيز قابلية القراءة والتواصل بين أعضاء الفريق.
### -------------------------------------------------------------------------- ChatGPT - End 02


في المستقبل بهذا المشروع ، هنعمل api وهناخد ال query string ونرسله لل server للحصول على كل articles اللي تحتوي على النص اللي بنبحث عنه .





--------------------------------------------------------------------------------------------------



سنتكلم في هذا ال commit عن بناء ال API ،
لابد من معرفة بعض المعلومات أولاً : 


**ال HTTP Protocol :** 
هو يقوم بعمل handle للإتصال بين ال frontend وال backend ،
### -------------------------------------------------------------------------- ChatGPT - Start 01
**أنا** : ممكن تقولي شرح مختصر عن ال http protocol ؟
**الروبوت** : بروتوكول HTTP (Hypertext Transfer Protocol) هو بروتوكول للاتصال وتبادل المعلومات عبر الإنترنت. يستخدم HTTP لنقل الموارد مثل صفحات الويب والصور وملفات الفيديو بين العميل (متصفح الويب) والخادم (الخادم الويب).

يعتمد HTTP على نموذج طلب/استجابة، حيث يقوم العميل بإرسال طلب للخادم ويستجيب الخادم بإرسال استجابة تحتوي على الموارد المطلوبة أو رمز حالة يشير إلى نجاح أو فشل الطلب. يتكون طلب HTTP من ثلاثة أجزاء رئيسية: الخط الأول (مثل GET أو POST) الذي يحدد نوع الطلب، رأس الطلب الذي يحتوي على المعلومات الإضافية للطلب، وجسم الطلب الذي يحمل البيانات الاختيارية مثل المعلمات أو البيانات المرسلة.

الـ HTTP يستخدم TCP/IP كبروتوكول نقل البيانات عبر الشبكة. يعمل على منفذ افتراضي وهو المنفذ 80 للاتصالات غير المشفرة، والمنفذ 443 للاتصالات المشفرة باستخدام بروتوكول HTTPS.

بالإضافة إلى ذلك، HTTP يتميز بالميزات التالية:

بساطة الاستخدام والفهم، مما يجعله مناسبًا للتطبيقات والبروتوكولات الويب.
يدعم مجموعة متنوعة من طرق الطلب مثل GET و POST و PUT و DELETE لتمكين إجراءات مختلفة على الموارد.
يعتمد على الرموز الحالة (مثل رمز 200 للنجاح ورمز 404 للصفحة غير موجودة) لتوفير معلومات حول حالة الاستجابة.
يدعم الحفاظ على الحالة والجلسة باستخدام مفهوم ملفات تعريف الارتباط (الكوكيز).
الـ HTTP هو البروتوكول الأساسي الذي يستخدمه الويب، ويتم تطويره وتحديثه باستمرار لتلبية احتياجات التطبيقات الحديثة.
### -------------------------------------------------------------------------- ChatGPT - End 01


**CRUD Operations :** 
Create & Read & Update & Delete

**HTTP Methods :** 
GET & POST & PUT & DELETE

**HTTP Request & HTTP Response :** 
حيث أن ال request هو الطلب المرسل من ال client لل server ، وال response هو الجواب المستلم من ال server لل client بناءاً على ال request ،

ال request وال response يعتبر object يتكون من جزئين : headers و body ، كالتالي : 
```
{ headers: {}, body:{} }
```
حيث أن ال headers يختوي على metadata يمعنى بيانات أو جزئيات مثل نوع البيانات والتاريخ وهكذا .... ، وال body يحتوي على ال data ، 


**HTTP Status Code** 
404 Not Found & 400 Bad Request & 200 Successful & 201 Created Successfully




كيف نبني API في Next.js ؟
نقوم بإنشاء فولدر جديد داخل ال app بإسم api  -هذا الإسم إجباري-
وداخل فولدر ال api هننشئ فولدر لكل page مطلوب إنشاء api endpoint لها ،
فمثلاً هنعمل فولدر جديد داخل ال api بإسم articles ، 
وداخل ال articles هنعمل ملف جديد بإسم route.ts -هذا الإسم إجباري- وبالتالي ال next.js هيتعرف على الملف أنه ملف ال api ،


نبني أول API ،
وهيكون من نوع GET ، ولاحظ أنه هناك أكثر من Method مثل POST ، PUT ، PATCH ، DELETE ، HEAD ، OPTIONS ،

نقوم الآن ببناء  API بإستخدام GET لجلب البيانات ، كالتالي : 
```ts
export function GET(){
}
```
ولابد أن يكون ال request من نوع GET ليتم اختيار وتنفيذ هذه ال function ، 
حيث أن ملف ال route.ts سيكون مكون من العديد من ال functions ، مثلاً GET و POST و PUT وهكذا ، 
فلابد أيضاً أن يكون الطلب من نوع GET ليتم تنفيذ هذه ال function بالذات .

ويتم تمرير ال request object لل function ، والذي يتم الحصول عليه من ال client ، 
ويكون من نوع NextRequest ، لذا نقوم بعمل import لل NextRequest من ال next/server كالتالي : 
```ts
import { NextRequest } from "next/server";

export function GET(request: NextRequest){
}
```
وهنعمل أيضاً import لل NextResponse من ال next/server أيضاً ، للتعامل مع ال response ، حيث سيتم إستخدامها كالتالي : 
```ts
return NextResponse.json()
```

فهنعمل array فقط لشرح جلب البيانات ، وكأن هذا ال array من ال database كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";
const articles = [
    {
        id:1,
        userId:101,
        title: 'Typescript',
        body: 'Typescript is a powerfull programming langauge'
    },
    {
        id:2,
        userId:102,
        title: 'PHP',
        body: 'PHP is a powerfull programming langauge'
    },
    {
        id:3,
        userId:103,
        title: 'CSharp',
        body: 'CSharp is a powerfull programming langauge'
    },
];

export function GET(request: NextRequest){
    return NextResponse.json(articles, {status:200});
}
```
لاحظ أننا كمان نقدر نحدد ال status code في ال argument التاني ،

وبالتالي لو دخلت على ال route التالي : 
http://localhost:3000/api/articles
فهيرجعلي بيانات ال articles الموجودة بال array ،
فال Default method هو ال GET ، وبالتالي عندما ندخل على هذا المسار ، فإن Next.js يقوم بالبحث عن GET method في ال route.ts داخل ال api/articles ، ويقوم بتنفيذ ال function ،

وممكن نعمل consle.log(request) داخل ال method لترجع كل بيانات ال request ، مثل : ال href ، origin ، ..... وهكذا كالتالي : 

```
NextRequest [Request] {
  [Symbol(realm)]: {
    settingsObject: { baseUrl: undefined, origin: [Getter], policyContainer: [Object] }
  },
  [Symbol(state)]: {
    method: 'GET',
    localURLsOnly: false,
    unsafeRequest: false,
    body: null,
    client: { baseUrl: undefined, origin: [Getter], policyContainer: [Object] },
    reservedClient: null,
    replacesClientId: '',
    window: 'client',
    keepalive: false,
    serviceWorkers: 'all',
    initiator: '',
    destination: '',
    priority: null,
    origin: 'client',
    policyContainer: 'client',
    referrer: 'client',
    referrerPolicy: '',
    mode: 'cors',
    useCORSPreflightFlag: false,
    credentials: 'same-origin',
    useCredentials: false,
    cache: 'default',
    redirect: 'follow',
    integrity: '',
    cryptoGraphicsNonceMetadata: '',
    parserMetadata: '',
    reloadNavigation: false,
    historyNavigation: false,
    userActivation: false,
    taintedOrigin: false,
    redirectCount: 0,
    responseTainting: 'basic',
    preventNoCacheCacheControlHeaderModification: false,
    done: false,
    timingAllowFailed: false,
    headersList: HeadersList {
      cookies: null,
      [Symbol(headers map)]: [Map],
      [Symbol(headers map sorted)]: [Array]
    },
    urlList: [ URL {} ],
    url: URL {
      href: 'http://localhost:3000/api/articles',
      origin: 'http://localhost:3000',
      protocol: 'http:',
      username: '',
      password: '',
      host: 'localhost:3000',
      hostname: 'localhost',
      port: '3000',
      pathname: '/api/articles',
      search: '',
      searchParams: URLSearchParams {},
      hash: ''
    }
  },
  [Symbol(signal)]: AbortSignal { aborted: false },
  [Symbol(abortController)]: AbortController { signal: AbortSignal { aborted: false } },
  [Symbol(headers)]: HeadersList {
    cookies: null,
    [Symbol(headers map)]: Map(20) {
      'accept' => [Object],
      'accept-encoding' => [Object],
      'accept-language' => [Object],
      'cache-control' => [Object],
      'connection' => [Object],
      'cookie' => [Object],
      'host' => [Object],
      'sec-ch-ua' => [Object],
      'sec-ch-ua-mobile' => [Object],
      'sec-ch-ua-platform' => [Object],
      'sec-fetch-dest' => [Object],
      'sec-fetch-mode' => [Object],
      'sec-fetch-site' => [Object],
      'sec-fetch-user' => [Object],
      'upgrade-insecure-requests' => [Object],
      'user-agent' => [Object],
      'x-forwarded-for' => [Object],
      'x-forwarded-host' => [Object],
      'x-forwarded-port' => [Object],
      'x-forwarded-proto' => [Object]
    },
    [Symbol(headers map sorted)]: [
      [Array], [Array], [Array],
      [Array], [Array], [Array],
      [Array], [Array], [Array],
      [Array], [Array], [Array],
      [Array], [Array], [Array],
      [Array], [Array], [Array],
      [Array], [Array]
    ]
  },
  [Symbol(internal request)]: {
    cookies: RequestCookies { _parsed: [Map], _headers: [HeadersList] },
    geo: {},
    ip: undefined,
    nextUrl: NextURL { [Symbol(NextURLInternal)]: [Object] },
    url: 'http://localhost:3000/api/articles'
  }
}
```


لعمل Test عال API فلن نستخدم المتصفح ، ولكن يمكننا إستخدام ال Postman والذي به العديد من الإمكانيات ،


للتنظيم ممكن نعمل ملف بإسم data.ts داخل فولدر utils ، ونقل ال articles array به ، ليتم إستيراده وإستخدامه بأي مكان ، كالتالي : 
```ts
import { Article } from "./types";

export const articles: Article[] = [
    {
        id:1,
        userId:101,
        title: 'Typescript',
        body: 'Typescript is a powerfull programming langauge'
    },
    {
        id:2,
        userId:102,
        title: 'PHP',
        body: 'PHP is a powerfull programming langauge'
    },
    {
        id:3,
        userId:103,
        title: 'CSharp',
        body: 'CSharp is a powerfull programming langauge'
    },
];
```

وبالتالي هنعمل إستيراد لل articles داخل ال route.ts وإستخدامها كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";
import { articles } from "@/utils/data";

export function GET(request: NextRequest){
    return NextResponse.json(articles, {status:200});
}
```




كما يمكننا تحديد Documentation لهذا ال API ، كالتالي : 
```ts
/**
 * @method  GET
 * @route   ~/api/articles
 * @desc    Get All Articles
 * @access  public
 */
```
حيث أن Tilde ~ تعبر عن ال domain ، وهذا ال documentation عبارة عن مرجع فقط ، ليكون الكود بالنهاية كالتالي : 

```ts
import { NextRequest, NextResponse } from "next/server";
import { articles } from "@/utils/data";

/**
 * @method  GET
 * @route   ~/api/articles
 * @desc    Get All Articles
 * @access  public
 */
export function GET(request: NextRequest) {
    return NextResponse.json(articles, { status: 200 });
}
```





-------------------------------------------------------------------------------------------------





في ال commit السابق تكلمنا عن ال GET Route Handler ،
سنتكلم في هذا ال commit عن ال POST Route Handler ل create article ،

ففي نفس الملف app/api/articles/route.ts هنعمل POST function كالتالي : 
```ts
export function POST(request: NextRequest){
    request.json()
}
```
ولازم الإسم يكون POST -الاسم إجباري- ، وذي ماقلنا أن ال request يحتوي على body ، فعايزين ناخد البيانات من المستخدم وإرسالها لل server ،
فنقوم بحفظ البيانات في const كالتالي : 
```ts
const body = request.json()
```
ولأنه asyncronus operation فلابد من عمل await ، وبالتالي فال function لابد أن تكون async كالتالي : 
```ts
export async function POST(request: NextRequest){
    const body = await request.json();
}
```
وعند الإنتهاء من تخزين البيانات المرسلة من ال client لل server يتم إرجاع رسالة 'created' وإرجاع ال status code كالتالي : 
```ts
export async function POST(request: NextRequest){
    const body = await request.json();
    return NextResponse.json({message: 'Created'}, {status:201});
}
```

هنعمل ال documentation ، وكمان ممكن نعمل console.log(body) عشان نطبع البيانات المستلمة من ال client ، كالتالي : 
```ts
/**
 * @method  POST
 * @route   ~/api/articles
 * @desc    Create A New Article
 * @access  public
*/
export async function POST(request: NextRequest){
    const body = await request.json();
    console.log(body);
    return NextResponse.json({message: 'Created'}, {status:201});
}
```


هنفتح ال Postman لعمل إرسال بيانات ، فهنعمل add request 
ممكن نسميه store ، وال method هتكون POST ، وهنكتب ال route كالتالي : 
http://localhost:3000/api/articles

ثم ندخل عال body ونختار raw ، ومنه نختار JSON ، 
وندخل البيانات كالتالي : 
```json
{
    "title": "Next.Js",
    "body": "Next.js is a framework"
}
```

ولأن ال method هي POST فإن ال next.js بيدخل عال route.ts يجيب ال function POST وينفذها ،
فعند إرسال البيانات ، سيتم إرجاع رسالة 'Created' وال status code = 201 ، وفي ال console هيرجع التالي : 
```json
{ title: 'Next.js', body: 'Next.js is a framework' }
```

خلينا بعد كده نكتب ال type الخاص ب body ، 
خد بالك مش هينفع نستخدم ال type Articel اللي عملناه قبل كده في ملف types.ts ،
وذلك لأنه يحتوي على التالي : 
```ts
export type Article = {
    id:number;
    userId:number;
    title:string;
    body:string
}
```
ولكننا عند إنشاء article جديد لن نحتاج ال id وال userId ،
وبالتالي يمكننا إنشاء type جديد مخصص فقط ل create new article ، ويحتوي فقط على title و body ،
فيمكننا إنشاءه في ملف ال route.ts ، 
ثم بعد ذلك نستخدمه بواسطة as ، في كود ال const body كالتالي : 
```ts
interface CreateArticleDto{
    title: string;
    body: string;
}

/**
 * @method  POST
 * @route   ~/api/articles
 * @desc    Create A New Article
 * @access  public
*/
export async function POST(request: NextRequest){
    const body = await request.json() as CreateArticleDto;
    console.log(body);
    return NextResponse.json({message: 'Created'}, {status:201});
}
```

وهذا الكود يقول لل typescript compiler أن يعتبر النتيجة لهذه العملية من نوع CreateArticleDto ، 
وتم تسمية هذا النوع بإضافة Dto وهو اختصار ل Data Transfer Object وهو إختصار شائع الإستخدام في التسمية ، 

ويمكننا الآن كتابة كود يجعلنا نضيف ال article لل client مباشرة بعد إضافته لل server ، بإستخدام push كالتالي : 
```ts
export async function POST(request: NextRequest){
    const body = await request.json() as CreateArticleDto;
    const newArticle: Article = {
        title: body.title,
        body: body.body,
        id: articles.length + 1,
        userId: 200
    }
    articles.push(newArticle);
    return NextResponse.json(newArticle, {status:201});
}
```
حيث أن ال id وال userId تم وضع بياناتهم بشكل fake لحين جلبها من ال database .
ولاحظ أنه تم تمرير ال newArticle بال argument الأول الخاص بالبيانات ، والتي يتم إرسالها لل client ، حتى يتم عرضها بالصفحة .


يتم التنفيذ على ال Postman ، وبالتالي هيرجع التالي : 
```json
{
    "title": "Next.Js",
    "body": "Next.js is a framework",
    "id": 4,
    "userId": 200
}
```


ولكن لو قام المستخدم بإرسال بيانات فارغة ، سيتم التنفيذ برضه ، وبالتالي عايزين نعمل Validation ، ويتم ذلك من خلال استخدام if condition ، كالتالي : 
```ts
if(body.title === "" || body.title.length < 2){
        return NextResponse.json({message: 'Title is Required'}, {status: 400});
}
```
ليكون الكود كاملاً كالتالي : 
```ts
export async function POST(request: NextRequest){
    const body = await request.json() as CreateArticleDto;
    if(body.title === "" || body.title.length < 2){
        return NextResponse.json({message: 'Title is Required'}, {status: 400});
    }

    const newArticle: Article = {
        title: body.title,
        body: body.body,
        id: articles.length + 1,
        userId: 200
    }
    articles.push(newArticle);
    return NextResponse.json(newArticle, {status:201});
}
```

ولو تم تجربة عمل submit بدون إدخال بيانات في ال Postman هيرجع التالي : 
```json
{
    "message": "Title is Required"
}
```
ولكن هذه الطريقة غير جيدة في كل الحالات ، لأنه تم عمل الشرط على حقل واحد فقط ، فممكن أوقات هيكون عندنا 10 حقول ، وبالتالي ال if condition هيكون معقد كثيراً جداً ، 
ولكن الأفضل أن نستخدم مكتبة تقوم بعمل ذلك ، مثل مكتبة Zod ، الموقع الرسمي لها : 
https://zod.dev/


-------------------------------------------------------------------------- ChatGPT - Start 01
أنا : ايه أهمية استخدام مكتبة zod في next.js ؟
الروبوت : مكتبة Zod هي مكتبة للتحقق من صحة البيانات في TypeScript. توفر Zod واجهة لتعريف وتطبيق قواعد التحقق من البيانات والتحقق من صحتها في تطبيقاتك. إليك بعض الأسباب التي قد تجعل استخدام مكتبة Zod مفيدة في Next.js:

التحقق من صحة البيانات: تسمح مكتبة Zod بتعريف مخططات (schemas) للبيانات وتحقق من صحتها. يمكنك تحديد نوع البيانات المتوقع والقيود والقواعد المطبقة على البيانات. هذا يساعد في التأكد من أن البيانات المستلمة أو المرسلة تتوافق مع التوقعات وتفادي الأخطاء المحتملة.

تبسيط التحقق من البيانات: باستخدام مكتبة Zod، يمكنك التحقق من صحة البيانات بسهولة بدون الحاجة إلى كتابة الكثير من الشفرة الإضافية. يمكنك تحويل البيانات المستلمة إلى هيئة مناسبة والتحقق من القيود المطلوبة بسهولة.

دعم TypeScript: مكتبة Zod تعمل بشكل ممتاز مع TypeScript وتعزز قدرات التحقق من الأنواع. يمكنك تعريف مخططات Zod باستخدام أنواع TypeScript والاستفادة من تحويل الأنواع والتعليمات البرمجية المساعدة المتاحة من TypeScript.

دعم مرحلة البناء والتصدير: يمكن استخدام مكتبة Zod في Next.js للتحقق من صحة البيانات في مرحلة البناء والتصدير. يعني ذلك أنه يمكنك التحقق من صحة البيانات أثناء بناء التطبيق وضمان عدم وجود أخطاء في البيانات المستخدمة في التطبيق النهائي.

باختصار، استخدام مكتبة Zod في Next.js يساعد في ضمان صحة البيانات وتسهيل تحققها وتبسيط عملية التحقق من البيانات. إذا كنت تحتاج إلى ضمان صحة البيانات في تطبيق Next.js الخاص بك، فقد تكون مكتبة Zod خيارًا جيدًا لتحقيق ذلك.
-------------------------------------------------------------------------- ChatGPT - End 01



Installation : 
```
> npm install zod
```

نقوم بإستخدامه كالتالي ، حسب ال documentation بتاعه : 
```ts
import { z } from 'zod';
```

وذلك داخل ملف ال route.ts ، 
ثم نقوم بعمل ال Validation بال zod بدلاً من إستخدام ال if condition ، 
فأولاً يتم فتح object جديد كالتالي : 
```ts
// Validation
    z.object({
        
    })
```
ثم يتم إضافة كل حقل على حده ، وتحديد ال schema كالتالي : 

```ts
// Validation
    z.object({
        title: z.string().min(2).max(200),
        body: z.string().min(10),
    });
```

نقوم بتعريف ال schema في const كالتالي : 
```ts
// Validation
    const createArticleSchema = z.object({
        title: z.string().min(2).max(200),
        body: z.string().min(10),
    });
```

ثم نعرف const validation كالتالي : 
```ts
const validation = createArticleSchema.safeParse(body);
```
-------------------------------------------------------------------------- ChatGPT - Start 02
أنا : ماهي ال safeParse() method ؟ ولماذا تم تمرير body بها ك Parameter ؟
الروبوت : الـ safeParse() هو أحد الأساليب المتوفرة في مكتبة Zod. يستخدم للتحقق من صحة البيانات بناءً على المخطط (schema) المعرف. تمرير body كمعامل إلى safeParse() يعني أنه يتم تطبيق التحقق من صحة البيانات على body باستخدام مخطط createArticleSchema.  -- حيث أن ال body الممررة في ال function عبارة عن البيانات المرسلة لل server ، وليس له علاقة بحقل body الموجود بجانب title ، فال body الممررة تحتوي على كل البيانات من ضمنها title و body وأي حقول أخري --

في الكود المعطى، createArticleSchema هو مخطط Zod يحدد تنسيق البيانات المتوقع لإنشاء مقال جديد. يحتوي على حقول title و body مع القيود المطلوبة لكل حقل.

باستخدام safeParse()، يتم التحقق من صحة body وفقًا لمخطط createArticleSchema. إذا كانت البيانات صالحة وتتوافق مع المخطط، فإن validation.success سيكون true. وإذا كانت البيانات غير صالحة أو لا تتوافق مع المخطط، فإن validation.success سيكون false وسيتم الوصول إلى validation.error للحصول على تفاصيل الأخطاء.

في حالة عدم نجاح التحقق من صحة البيانات، يتم إرجاع استجابة JSON بالأخطاء المحددة ورمز الحالة 400 (Bad Request) باستخدام NextResponse.json() من Next.js. هذا يسمح بإعلام العميل بالأخطاء المحددة وتوفير استجابة مناسبة للطلب الذي لم يمر بالتحقق من الصحة.
-------------------------------------------------------------------------- ChatGPT - End 02
ثم نعمل شرط للتحقق من ال validation كالتالي : 
```ts
// Validation
    const createArticleSchema = z.object({
        title: z.string().min(2).max(200),
        body: z.string().min(10),
    });

    const validation = createArticleSchema.safeParse(body);

    if(!validation.success){
        return NextResponse.json(validation.error, {status: 400});
    }
```

فهنا لو نفذنا الكود بإستخدام ال postman مع إرسال قيحة حقل فارغ ، ستظهر لنا النتيجة التالية : 
```
{
    "issues": [
        {
            "code": "too_small",
            "minimum": 2,
            "type": "string",
            "inclusive": true,
            "exact": false,
            "message": "String must contain at least 2 character(s)",
            "path": [
                "title"
            ]
        }
    ],
    "name": "ZodError"
}
```

فكيف يمكننا الحصول على ال message ، 
لو لاحظنا سنجد أن ال issues هو array ، وأن ال message موجود بأول object في ال array ، 
فيمكننا تعديل الكود كالتالي : 
```ts
return NextResponse.json({message: validation.error.errors[0].message}, {status: 400});
```

وبالتالي لو بعتنا request بال Postman سيرجع لنا التالي : 
```json
{
    "message": "String must contain at least 2 character(s)"
}
```


وللتنظيم ، يمكننا إنشاء ملف خاص بال Validation Schema لكل ال Application ، بإسم validationSchemas.ts داخل utils ،
ونقوم بعمل export لل const ليكون كود ملف ال validationSchemas.ts كالتالي : 
```ts
import { z } from "zod";

// Validation
export const createArticleSchema = z.object({
    title: z.string().min(2).max(200),
    body: z.string().min(10),
});
```

ولو عايزين نحدد ال message لكل method يكون من خلال اضافة argument ثاني بال message مثل : 
```ts
title: z.string().min(2, 'The Title Must >= 2').max(200),
```


وكود ال function POST كالتالي : 
```ts
export async function POST(request: NextRequest){
    const body = await request.json() as CreateArticleDto;

    const validation = createArticleSchema.safeParse(body);

    if(!validation.success){
        return NextResponse.json({message: validation.error.errors[0].message}, {status: 400});
    }

    const newArticle: Article = {
        title: body.title,
        body: body.body,
        id: articles.length + 1,
        userId: 200
    }
    articles.push(newArticle);
    return NextResponse.json(newArticle, {status:201});
}
```

وللتنظيم أيضاً ، يمكننا إنشاء ملف بإسم dtos.ts وهذا لكل ال Dto الخاصة بال Application ، وننقل كود ال interface CreateArticleDto به ، ليكون ملف ال dtos.ts كالتالي : 
```ts
export interface CreateArticleDto{
    title: string;
    body: string;
}
```



ليكون في النهاية كود ال route.ts كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";
import { articles } from "@/utils/data";
import { Article } from "@/utils/types";
import { createArticleSchema } from "@/utils/validationSchemas";
import { CreateArticleDto } from '@/utils/dtos';

/**
 * @method  GET
 * @route   ~/api/articles
 * @desc    Get All Articles
 * @access  public
 */
export function GET(request: NextRequest) {
    return NextResponse.json(articles, { status: 200 });
}


/**
 * @method  POST
 * @route   ~/api/articles
 * @desc    Create A New Article
 * @access  public
*/
export async function POST(request: NextRequest){
    const body = await request.json() as CreateArticleDto;

    const validation = createArticleSchema.safeParse(body);

    if(!validation.success){
        return NextResponse.json({message: validation.error.errors[0].message}, {status: 400});
    }

    const newArticle: Article = {
        title: body.title,
        body: body.body,
        id: articles.length + 1,
        userId: 200
    }
    articles.push(newArticle);
    return NextResponse.json(newArticle, {status:201});
}
```


وكود ال validationSchemas.ts كالتالي : 
```ts
import { z } from "zod";

// Validation
export const createArticleSchema = z.object({
    title: z.string().min(2).max(200),
    body: z.string().min(10),
});
```



وكود ال dtos.ts كالتالي : 
```ts
export interface CreateArticleDto{
    title: string;
    body: string;
}
```





--------------------------------------------------------------------------------






هنتكلم في هذا ال commit عن ال route الخاص بال single object ، 
وفي هذا المثال هو ال single article ،

فعايزين نعمل API endpoint لل single article ،
ليكون كالتالي : 

~/api/articles/1


وخد بالك ال id هيكون dynamic ، بمعنى ممكن يبقى 1 او 2 او 70 وهكذا ....

فعشان نعمل dynamic route في next.js في مثالنا ، هنعمل فولدر جديد بإسم [id] داخل src/app/api/articles ،
ثم نقوم بإنشاء فايل route.ts داخله ،

وبداخل هذا الملف ، هنعمل import أولاً لل NextRequest و NextResponse من 'next/server' كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";
```

ثم نقوم بعمل ال documentation كالتالي : 
```ts
/**
 * @method  GET
 * @route   ~/api/articles/:id
 * @desc    Get Single Article By Id
 * @access  public
*/
```

احنا كتبنا : قبل ال id لتعبر عن ان ال id سيكون dynamic ، 

وهنعمل import لل articles من ملف ال data.ts اللي فصلناه وأنشأناه داخل ال utils ليكون كالتالي : 
```ts
import { articles } from "@/utils/data";
```

وعشان نجيب ال dynamic id المكتوب في ال route ونستخدمه داخل ال function ، يتم ذلك من خلال ال parameter الثاني ، وهو props كالتالي : 
```ts
export function GET(request: NextRequest, props:any){
    return NextResponse.json(props);
}
```
هتطلع النتيجة كالتالي : 
```json
{
  "params": {
      "id": "2"
   }
}
```

هنعمل type interface لل props كالتالي : 
```ts
interface Props{
    params:{ id:string }
}
```

وهنعمل object destructuring وناخد ال params كالتالي : 
```ts
interface Props{
    params:{ id:string }
}

/**
 * @method  GET
 * @route   ~/api/articles/:id
 * @desc    Get Single Article By Id
 * @access  public
*/

export function GET(request: NextRequest, {params} : Props){
    return NextResponse.json(params);
}
```

هتطلع النتيجة كالتالي : 
```json
  {
    "id": "2"
  }
```


وعشان نجيب بيانات ال single article هيكون كالتالي : 
```ts
export function GET(request: NextRequest, {params} : Props){
    const article = articles.find(a => a.id === params.id);
}
```
ولكن هيطلع error لأن ال id عبارة عن number وال params.id عبارة عن string ، وبالتالي هنستخدم parseInt function كالتالي : 
```ts
export function GET(request: NextRequest, {params} : Props){
    const article = articles.find(a => a.id === parseInt(params.id));

    return NextResponse.json(article, {status:200});
}
```


بفرض أن المستخدم فتح لينك ل Article غير موجود ، عايزين نرجع رسالة ، هيكون كالتالي : 
```ts
export function GET(request: NextRequest, {params} : Props){
    const article = articles.find(a => a.id === parseInt(params.id));

    if(!article){
        return NextResponse.json({message: 'This Article Is Not Found'}, {status: 404});
    }

    return NextResponse.json(article, {status:200});
}
```

وهنضيف ال request هذا لل postman ،
ولو لاحظنا في ال postman عندنا الدومين localhost:3000 ، ممكن عمل variable لهذا الدومين ، وإستخدامه في كل ال routes بدلاً من كتابته كل مرة ،
مثلا بإسم DOMAIN ونكتب ال route في ال postman كالتالي : 
Route:   {{DOMAIN}}/api/articles/3




نقوم الآن بعمل Update لل article ، سيكون بنفس الملف ، وذلك لأنه سيكون نفس ال route بإختلاف ال method type فقط كالتالي : 

```ts
/**
 * @method  PUT
 * @route   ~/api/articles/:id
 * @desc    Update Single Article By Id
 * @access  public
  */

export function PUT(request: NextRequest, {params}: Props){
    const article = articles.find(a => a.id === parseInt(params.id));
    if(!article){
        return NextResponse.json({message: 'Article Is Not Found'}, {status: 404});
    }

    return NextResponse.json({message: 'Article Was Updated'}, {status:200});
}
```

ثم نقوم بإضافة interface UpdateArticleDto بملف dtos.ts ليكون كالتالي : 
```ts
export interface UpdateArticleDto{
    title?: string;
    body?: string;
}
```
وخد بالك أننا قمنا بإضافة ? لل key ، وده ليعبر عن ان هذا العنصر سيكون اختياري ، بمعنى ممكن تعديله وممكن لأ ،
فممكن المستخدم يدخل يعدل ال title ولا يعدل ال body أو العكس ، 

ثم نقوم بعمل import ل UpdateArticleDto بملف ال route وإستخدامها ليكون الملف كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";
import { articles } from "@/utils/data";
import { UpdateArticleDto } from "@/utils/dtos";

interface Props{
    params:{ id:string }
}

/**
 * @method  GET
 * @route   ~/api/articles/:id
 * @desc    Get Single Article By Id
 * @access  public
*/

export function GET(request: NextRequest, {params} : Props){
    const article = articles.find(a => a.id === parseInt(params.id));

    if(!article){
        return NextResponse.json({message: 'This Article Is Not Found'}, {status: 404});
    }

    return NextResponse.json(article, {status:200});
}



/**
 * @method  PUT
 * @route   ~/api/articles/:id
 * @desc    Update Single Article By Id
 * @access  public
  */

export async function PUT(request: NextRequest, {params}: Props){
    const article = articles.find(a => a.id === parseInt(params.id));
    if(!article){
        return NextResponse.json({message: 'Article Is Not Found'}, {status: 404});
    }

    const body = await request.json() as UpdateArticleDto;
    console.log(body);
    
    return NextResponse.json({message: 'Article Was Updated'}, {status:200});
}
```




ثم نقوم الأن بعمل Delete Article كالتالي : 
```ts
/**
 * @method  DELETE
 * @route   ~/api/articles/:id
 * @desc    Delete Single Article By Id
 * @access  public
 */

export function DELETE(request: NextRequest, {params}:Props){
    const article = articles.find(a => a.id === parseInt(params.id));
    if(!article){
        return NextResponse.json({message: 'Article Is Not Found'}, {status: 404});
    }

    return NextResponse.json({message: 'Article Was Deleted Successfully'}, {status:200});
}
```

ثم نضيف ال route لل postman ونعمل save .






نقوم الآن بتنزيل لبرنامج postgresql من ال link التالي : 
https://www.postgresql.org/download/

ويتم تسطيبه بشكل عادي ، مع ملاحظة أنه سيحتاج منك أن تضع له password سيطلبه منك عند التواصل بأي قاعدة بيانات ،

بعد التسطيب ، هيكون عندنا حاجتين : pgAdmin & SQL Shell ومن خلالهم نقدر نتواصل مع قاعدة البيانات بتاعتنا ، 
ال pgAdmin هي واجهة رسومية ، عند فتحه ممكن يطلب مني password جديد لل pgAdmin لأول مرة فقط ،
 
من ال sidebar هنضغط على server -> postgreSQL ، بعدها هيطلب مننا ال password الخاص بال postgresql اللي تم إنشاءه عند تسطيب البرنامج ،
ليفتح أمامنا قاعدة البيانات ، 


وللإحتراف بقاعدة البيانات ، يمكننا إستخدام SQL Shell أفضل من ال pgAdmin ، 
عند فتحه سيطلب منك البيانات التالية : 
```cmd
Server [localhost]:
Database [postgres];
Port [5432]:
Username [postgres]:
Password for user postgres:
```

لاحظ أنه كاتب القيم بنفسه زي localhost و postgres و 5432 ، فقط علينا أن نضغط Enter ،
ولكن علينا كتابة ال password فقط ، مع ملاحظة أنك لما تكتب ال password هيظهر كأنك لم تكتب شئ ويكون مخفي ، فهو يقرأه ، ادخل ال password ثم اضغط Enter ،
بعدها هيتم عمل الإتصال ،

فيمكنك كتابة أي أمر أمام كلمة : 
```
postgres=# ................
```






------------------------------------------------------------------------------------






هنتكلم في هذا ال commit عن ال Prisma ،
ال Prisma هو ORM أي Object Relationship Mapping ،
فقواعد البيانات مثل MySql لها لغات خاصة بهم اللي هي ال SQL ،

فإذاً لابد من كتابة SQL بالمشروع ، ولكن يمكننا إستخدام Prisma لإمكانية كتابة Javascript code ، 
ليقوم ال Prisma خلف الكواليس بتحويل ال Javascript code إلى SQL code ،

فلتثبيت ال Prisma نقوم بالأمر التالي : 
```
> npm i -D prisma
```

لمعرفة الأوامر المتاحة في Prisma والتي سنستخدمها بالمشروع ، يمكن إعطاء هذا الأمر : 
```
> npx prisma
```

سيخرج لنا هذه النتيجة : 
```
Commands

            init   Set up Prisma for your app
        generate   Generate artifacts (e.g. Prisma Client)
              db   Manage your database schema and lifecycle
         migrate   Migrate your database
          studio   Browse your data with Prisma Studio
        validate   Validate your Prisma schema
          format   Format your Prisma schema
         version   Displays Prisma version info
           debug   Displays Prisma debug info

Flags

     --preview-feature   Run Preview Prisma commands
     --help, -h          Show additional information about a command

Examples

  Set up a new Prisma project
  $ prisma init

  Generate artifacts (e.g. Prisma Client)
  $ prisma generate

  Browse your data
  $ prisma studio

  Create migrations from your Prisma schema, apply them to the database, generate artifacts (e.g. Prisma Client)
  $ prisma migrate dev

  Pull the schema from an existing database, updating the Prisma schema
  $ prisma db pull

  Push the Prisma schema state to the database
  $ prisma db push

  Validate your Prisma schema
  $ prisma validate

  Format your Prisma schema
  $ prisma format

  Display Prisma version info
  $ prisma version

  Display Prisma debug info
  $ prisma debug
```

فلتثبيت Prisma client بالمشروع هنكتب الأمر التالي : 
```
> npx prisma init
```

فبعد هذا الأمر مباشرة سنجد أنه عمل فولدر جديد بالمشروع بإسم prisma وداخله ملف بإسم schema.prisma وهو أهم ملف في ال Prisma ،
وهنلاقي فيه 2 objects ، ال client وال db ، كالتالي : 
```js
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
```
وطبعاً في ال db provider يمكننا تحديد نوع ال database ، فمثلاً لو ال database من نوع mysql  كنا هنكتب "mysql" في ال provider ،

وسنلاحظ وجود url أيضاً داخل ال db ، حيث سيكون قيمته مخزنة في ملف ال env ، 
وهذا الملف أيضاً تم إنشاءه تلقائياً بمجرد تنفيذ الأمر npx prisma init ،

وهنلاقي محتوى ال .env كالتالي : 
```js
DATABASE_URL="postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public"
```
ولكن سيتم تعديله بال username وال password اللي عملناهم في ال postgresql ، وهما 
username = postgresql
password = 1380031

ونحدد أيضاً اسم ال database اللي هنعملها في ال postgresql لتكون مثلاً بإسم SakrDB
ليصبح ال url كالتالي : 
```js
DATABASE_URL="postgresql://postgresql:1380031@localhost:5432/SakrDB?schema=public"
```
وخد بالك إننا لازم نضيف ملف ال env في ال gitignore ، لأنه سيحتوي على كل ال usernames وال passwords الموجودة بالتطبيق ،




نقوم الآن بتحديد ال models الخاصة بالمشروع ، وهم ال User وال Article وال Comment ،
ويتم ذلك داخل ملف ال schema.prisma ،

فنقوم بإنشاء model User كالتالي : 

العمود الأول id من نوع Integer ، ولجعل ال database تقوم بعمل generate لهذا ال id بنفسها وبكون فريد من نوعه ويأخذ خواص ال id سنضيف id@ ، فهنضيف كمان default(autoincrement())@ ليكون كالتالي : 
```js
model User{
  id  Int @id @default(autoincrement())
}
```

وهنعمل عامود اخر لل email ، واللي هيكون من نوع string ، وهيكون فريد من نوعه كالتالي : 
```js
model User{
  id  Int @id @default(autoincrement())
  email String @unique
}
```

وهنعمل عامود لل username وهيكون من نوع String ، وعايزين ال max length تكون 100 كالتالي : 
```js
model User{
  id  Int @id @default(autoincrement())
  email String @unique
  username  String @db.VarChar(100) // maxLength(100)
  password  String
  isAdmin Boolean @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```
لاحظ أيضاً أنه تم عمل أعمدة ال password وال isAdmin و createdAt و updatedAt ،
وأن ال updatedAt يأخذ updatedAt@ directive ، والتي تقوم بوضع التاريخ عند أي تحديث على ال record ،

وخد بالك أن كل هذه الحقول كده required ، ولو عايز حقل منهم يكون optional هنضيف علامة ? بعد ال type مباشرة كالتالي : 
```
email String? @unique
```

هنعمل ال model Article كالتالي : 
```js
model Article{
  id Int @id @default(autoincrement())
  title String @db.VarChar(200)
  description String
  createdAt DateTime @default(now())
  updatedAt DateTime  @updatedAt
}
```

ونعمل ال model comment كالتالي : 
```js
model Comment{
  id Int @id @default(autoincrement())
  articleId Int
  text String
  createdAt DateTime @default(now())
  updatedAt DateTime  @updatedAt
}
```


هنعمل بقى دلوقتى العلاقات Relationship بين الجداول ، 
فعندنا علاقة بين Article و Comment من نوع One To Many ، بمعنى أن كل Article سيحتوى على الكثير من ال Comments ، فتتم ذلك ببعض الإجراءات على الجدولين ،

أولاً جدول ال Article وهو ال parent ، يتم من خلال إضافة الكود التالي بنهاية ال model ليكون كالتالي : 
```js
model Article{
  id Int @id @default(autoincrement())
  title String @db.VarChar(200)
  description String
  createdAt DateTime @default(now())
  updatedAt DateTime  @updatedAt
  
  // One-To-Many Relation between Article & Comment
  comments Comment[]
}
```

ثانياً جدول ال Comment وهو ال child ، ويتم من خلال إضافة الكود التالي بنهاية ال model كالتالي : 

```js
model Comment{
  id Int @id @default(autoincrement())
  articleId Int
  text String
  createdAt DateTime @default(now())
  updatedAt DateTime  @updatedAt

  // One-To-Many Relation between Article & Comment
  article Article @relation(fields: [articleId], references: [id])
}
```




عايزين نعمل علاقة أخرى بين المستخدم User model وال Comments وستكون علاقة من نوع One To Many أيضاً ، لأن المستخدم يستطع كتابة الكثير من ال comments ،
فهنروح لل parent model ونضيف ال child array كالتالي : 

```js
model User{
  id  Int @id @default(autoincrement())
  email String @unique
  username  String @db.VarChar(100) // maxLength(100)
  password  String
  isAdmin Boolean @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // One-To-Many Relation between User & Comment
  comments Comment[]
}
```

وهنضيف العلاقة في جدول ال child أيضاً كالتالي : 
```js
model Comment{
  id Int @id @default(autoincrement())
  text String
  createdAt DateTime @default(now())
  updatedAt DateTime  @updatedAt
  articleId Int
  userId Int

  // One-To-Many Relation between Article & Comment
  article Article @relation(fields: [articleId], references: [id])

  // One-To-Many Relation between User & Comment
  user  User @relation(fields: [userId], references: [id])
}
```


فبعد كل هذا ، يمكننا عمل ال migration لبناء قاعدة البيانات بالجداول اللي عملناها ، هنعمل الأمر التالي : 
```
> npx prisma migrate dev
```

هيطلب مننا اسم لل migration ، ممكن نكتبه كالتالي : 
CreatingUserTableArticleTableCommentTable


ولكن لوجود مشكلة عندي بال postgreSQL فسنقوم بالتطبيق على MySql بدلاً من postgreSQL ،
فسيتم تعديل ال datasource db في ال schema.prisma لتكون كالتالي : 
```js
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}
```

ويتم تعديل ال database url في ال env ليكون كالتالي : 
```js
DATABASE_URL="mysql://root:@localhost:3306/test_prisma"
```

علماً بأنه تم إنشاء قاعدة بيانات أولاً بإسم test_prisma في mysql ، 
وخد بالك اننا في ال mysql الباسورد بيكون فاضي ، وبالتالي لم يتم كتابته في ال database url ، فبفرض أننا عندنا يوزرنيم باسم sakr وباسورد 123456 سيكون ال url كالتالي : 
DATABASE_URL="mysql://sakr:123456@localhost:3306/test_prisma"
نقوم بعد ذلك بتنفيذ الأمر التالي لعمل ال migration : 
```
> npx prisma migrate dev
```

سنجد أنه تم إنشاء فولدر جديد بإسم migrations داخل فولدر prisma ، 
وداخل هذا الفولدر سنجد فولدر بإسم ال migration وداخله ملف بإسم migration.sql وبه أكواد sql لإنشاء الجداول المطلوبة ، كالتالي : 

```sql
-- CreateTable
CREATE TABLE `User` (
    `id` INTEGER NOT NULL AUTO_INCREMENT,
    `email` VARCHAR(191) NOT NULL,
    `username` VARCHAR(100) NOT NULL,
    `password` VARCHAR(191) NOT NULL,
    `isAdmin` BOOLEAN NOT NULL DEFAULT false,
    `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `updatedAt` DATETIME(3) NOT NULL,

    UNIQUE INDEX `User_email_key`(`email`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Article` (
    `id` INTEGER NOT NULL AUTO_INCREMENT,
    `title` VARCHAR(200) NOT NULL,
    `description` VARCHAR(191) NOT NULL,
    `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `updatedAt` DATETIME(3) NOT NULL,

    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Comment` (
    `id` INTEGER NOT NULL AUTO_INCREMENT,
    `text` VARCHAR(191) NOT NULL,
    `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `updatedAt` DATETIME(3) NOT NULL,
    `articleId` INTEGER NOT NULL,
    `userId` INTEGER NOT NULL,

    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- AddForeignKey
ALTER TABLE `Comment` ADD CONSTRAINT `Comment_articleId_fkey` FOREIGN KEY (`articleId`) REFERENCES `Article`(`id`) ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Comment` ADD CONSTRAINT `Comment_userId_fkey` FOREIGN KEY (`userId`) REFERENCES `User`(`id`) ON DELETE RESTRICT ON UPDATE CASCADE;
```



ويمكننا التعامل مباشرة على Prisma Studio وهو عبارة عن واجهة جيدة تعرض الجداول الموجودة بقاعدة البيانات ، 
ويتم فتحه من خلال الأمر التالي : 
```
> npx prisma studio
```

سيفتح لنا بالمتصفح صفحة بالرابط التالي : 
http://localhost:5555/
ويكون التعامل مع قاعدة البيانات أفضل وأسرع ،


وخد بالك إننا لو اضفنا model جديد أو عملنا أي تغيير بال schema.prisma لازم ننفذ أمر ال migration بعدها كالتالي : 
```
> npx prisma migrate dev
```






-----------------------------------------------------------------------------------------





هنتكلم في هذا ال commit عن ال prisma client ،

ففي ال commit السابق تكلمنا عن ال Prisma ORM ، 
وتعملنا أنه عند تنفيذ أمر npx prisma init فإنه يتم إنشاء فولدر ال prisma وداخله ال schema.prisma وأيضاً ملف env ،

ويقوم أيضاً بعمل ال Prisma Client ، وستجد أنه تم إضاقتها بال dependencies بملف ال package.json ، 
حيث أننا نقوم بالتواصل بقاعدة البيانات من خلال ال Prisma Client ، 



فنقوم بتطبيق وإستخدام ال prisma client بال articles بملف api/articles/route.ts بال POST function ،
حيث نقوم بتعديل الكود لنقوم بتخزين ال records الجديدة بقاعدة البيانات بدلاً من عمل push بال articles array ،


فنقوم أولاً بعمل import ل PrismClient كالتالي : 
```ts
import { PrismaClient } from "@prisma/client";
```

وهنعمل object من ال PrismaClient ومن خلاله يتم التواصل بال database كالتالي : 
```ts
const prisma = new PrismaClient();
```

فهنلاحظ بعدها عند كتابة prisma. سيتم عمل إفتراحات بأسماء الجداول الموجودة بقاعدة البيانات ،
هنعدل اسم العمود بتاع body ليكون decription في كلاً من dtos.ts و types.ts وال validationSchemas.ts ، 

وال const newArticle هنخليها تساوي ال prisma ثم اسم الجدول article ثم create function ثم data:{} وبداخلها الأعمدة المطلوب ملأها ،
ولاحظ أن ال id و createdAt يتم تعبئتهم تلقائياً ، 
ولاحظ أيضاً أننا سنستخدم await ليكون الكود كالتالي : 
```ts
const newArticle = await prisma.article.create({
        data:{
            title: body.title,
            description: body.description
        }
    })
```

وعشان ال typescript ، فلازم نحدد نوع ال newArticle ، فلأننا في ال prisma تم تحديد أنواع عناصر ال object اللي هي الأعمدة اللي في الجدول ،
فيمكننا إستخدام ال Article model كنوع لل newArticle ، ولكن علينا عمل import له مع ال PrismaClient كالتالي : 
```ts
import { PrismaClient, Article } from "@prisma/client";
```

ونستخدمه كالتالي : 
```ts
const newArticle:Article = await prisma.article.create({
        data:{
            title: body.title,
            description: body.description
        }
    })
```


فهنجرب دلوقتى إنشاء article جديد من خلال ال postman هنلاقي كل حاجة تمام وأنه بينشئ records جديدة بشكل مظبوط ، 

هندخل بعد كده على قاعدة البيانات ال Prisma Studio من خلال الأمر : 
```
> npx prisma studio
```

هنلاقي البيانات اللي دخلناها بال postman موجودة بال prisma studio وبال mysql وكله تمام .


خد بالك اننا لازم نخلي الأكواد اللي داخل ال POST function نضعها داخل try , cathc ،
فلو كله تمام فال try هيشتغل ، وإلا لو هناك أي error من قاعدة البيانات فال catch هتشتغل ، ليكون كود ال POST request فالنهاية كالتالي : 

```ts
export async function POST(request: NextRequest){
    try{
        const body = await request.json() as CreateArticleDto;

        const validation = createArticleSchema.safeParse(body);
    
        if(!validation.success){
            return NextResponse.json({message: validation.error.errors[0].message}, {status: 400});
        }
    
        const newArticle:Article = await prisma.article.create({
            data:{
                title: body.title,
                description: body.description
            }
        })
        return NextResponse.json(newArticle, {status:201});
    }catch(error){
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
    
}
```




ننتقل بعد كده لل GET request ،
ونقوم بإستخدام ال prisma به لجلب البيانات من ال database ، وهنستخدم try, catch وكمان async, await ليكون الكود كالتالي : 
```ts
export async function GET(request: NextRequest) {
    try {
        const articles = await prisma.article.findMany();
        return NextResponse.json(articles, {status: 200});
    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```

ولو دخلنا عال postman أو ال api link هنلاقي كله شغال تمام وتم عرض كل ال articles .




ننتقل بعد كده ل Get Single Article ،
هندخل على ملف api/articles/[id]/route.ts ،
ونعمل import لل PrismaClient وال Article model كالتالي : 
```ts
import { PrismaClient, Article } from "@prisma/client";
```

وهنعرف const لل prisma كالتالي : 
```ts
const prisma = new PrismaClient();
```

ثم في ال GET request هنستخدم ال prisma مع findUnique function ، وهيكون داخلها object بإسم where لتمرير ال id به ، ليكون الكود النهائي لل GET request كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";
import { articles } from "@/utils/data";
import { UpdateArticleDto } from "@/utils/dtos";
import { PrismaClient, Article } from "@prisma/client";

interface Props{
    params:{ id:string }
}

const prisma = new PrismaClient();

/**
 * @method  GET
 * @route   ~/api/articles/:id
 * @desc    Get Single Article By Id
 * @access  public
*/

export async function GET(request: NextRequest, {params} : Props){
    try {
        const article = await prisma.article.findUnique({where:{id: parseInt(params.id)}});
        if(!article){
            return NextResponse.json({message: 'This Article Is Not Found'}, {status: 404});
        }
    
        return NextResponse.json(article, {status:200});
    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```




ولكن خد بالك اننا عملنا prisma object بكل ملف على حده من خلال الكود هذا : 
```ts
const prisma = new PrismaClient();
```
وهذا يسمى بال Bad Practice ، فلا يفضل تكرار عمل ال object ،
ولهذا يمكننا عمل ملف بإسم db.ts داخل فولدر ال utils ، 
وداخل هذا الملف نعمل import لل PrismaClient ثم ننشئ const prisma من هذا ال object ثم نعمل له export default كالتالي : 
```ts
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

export default prisma;
```

وبعدها يمكن عمل import لل const prisma بأي ملف نستخدمه به ، ونمسح ال  const prisma القديم ليكون ملف api/articles/route.ts كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";
import { createArticleSchema } from "@/utils/validationSchemas";
import { CreateArticleDto } from '@/utils/dtos';
import { Article } from "@prisma/client";
import prisma from "@/utils/db";


/**
 * @method  GET
 * @route   ~/api/articles
 * @desc    Get All Articles
 * @access  public
 */
export async function GET(request: NextRequest) {
    try {
        const articles = await prisma.article.findMany();
        return NextResponse.json(articles, {status: 200});
    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}


/**
 * @method  POST
 * @route   ~/api/articles
 * @desc    Create A New Article
 * @access  public
*/
export async function POST(request: NextRequest){
    try{
        const body = await request.json() as CreateArticleDto;

        const validation = createArticleSchema.safeParse(body);
    
        if(!validation.success){
            return NextResponse.json({message: validation.error.errors[0].message}, {status: 400});
        }
    
        const newArticle:Article = await prisma.article.create({
            data:{
                title: body.title,
                description: body.description
            }
        })
        return NextResponse.json(newArticle, {status:201});
    }catch(error){
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
    
}
```



ويكون الكود الخاص بال Get Single Article بملف api/articles/[id]/route.ts كالتالي : 

```ts
import { NextRequest, NextResponse } from "next/server";
import { articles } from "@/utils/data";
import { UpdateArticleDto } from "@/utils/dtos";
import prisma from "@/utils/db";

interface Props{
    params:{ id:string }
}

/**
 * @method  GET
 * @route   ~/api/articles/:id
 * @desc    Get Single Article By Id
 * @access  public
*/

export async function GET(request: NextRequest, {params} : Props){
    try {
        const article = await prisma.article.findUnique({where:{id: parseInt(params.id)}});
        if(!article){
            return NextResponse.json({message: 'This Article Is Not Found'}, {status: 404});
        }
    
        return NextResponse.json(article, {status:200});
    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```






-------------------------------------------------------------------------------





نتكلم في هذا ال commit عن ال PUT وال DELETE route handler ،
فهنعمل ال PUT route handler أولاً ،

فبالملف api/articles/[id]/route.ts ، نقوم بالتعديل على PUT method ،
فنقوم بعمل ال try وال catch أولاً لتكون كالتالي : 

```ts
export async function PUT(request: NextRequest, {params}: Props){
    try {
       // The code here ....
    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```

ونقوم بكتابة الكود بتاعنا في ال try ،
نقوم أولاً بإستحضار ال article اللي هيتعمل عليه التعديل كالتالي : 
```ts
const article = await prisma.article.findUnique({
            where:{ id:parseInt(params.id)}
        });
```
مع العلم أن ال findUnique هي بالظبط مثلها مثل ال findFirst فكلاهم يستحضر ال Single Object ،
ولكن ال findUnique تستخدم في حالة عدم تكرار عنصر البحث ، بمعنى أن ال id لن يتكرر أبداً في هذا الجدول ، 

ولن نستطع أن نستخدم ال findUnique مع ال title ، لأنه قد يوجد أكثر من record بنفس ال title ، وإلا فنستخدم ال findFirst ،

ثم نتحقق من وجود ال article كالتالي : 
```ts
if(!article){
            return NextResponse.json({message: 'Article Is Not Found'}, {status: 404});
        }
```

ثم نقوم بكتابة بتعريف const ليقوم بإرجاع ال request.json ويكون طبقاً ل UpdateArticleDto كالتالي : 
```ts
const body = await request.json() as UpdateArticleDto;
```

ثم نقوم بكتابة كود ال update بإستخدام ال prisma كالتالي : 
```ts
await prisma.article.update()
```
ولكن لابد من تحديد ال article الذي سيتم عمل update له بإستخدام where object ، وأيضاً يتم تحديد البيانات المطلوب تحديثها من خلال ال data object ، كما يمكن وضعها ب const كالتالي : 

```ts
const updatedArticle = await prisma.article.update({
            where: {id: parseInt(params.id)},
            data:{
                title: body.title,
                description: body.description
            }
        });
```

ليكون الكود بالنهاية كالتالي : 
```ts
export async function PUT(request: NextRequest, {params}: Props){
    try {
        const article = await prisma.article.findUnique({
            where:{ id:parseInt(params.id)}
        });
        if(!article){
            return NextResponse.json({message: 'Article Is Not Found'}, {status: 404});
        }

        const body = await request.json() as UpdateArticleDto;
        const updatedArticle = await prisma.article.update({
            where: {id: parseInt(params.id)},
            data:{
                title: body.title,
                description: body.description
            }
        });

        return NextResponse.json(updatedArticle, {status:200});
    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```

يمكننا تجربة ال Put route handler على ال Postman للتأكد من أن كل شئ على مايرام ،





ثم نقوم بعد ذلك بالتعديل على Delete route handler لتكون كالتالي : 
```ts
export async function DELETE(request: NextRequest, {params}:Props){
    try {
        const article = await prisma.article.findUnique({
            where: {id: parseInt(params.id)}
        });
        if(!article){
            return NextResponse.json({message: 'Article Is Not Found'}, {status: 404});
        }
        await prisma.article.delete({where:{id: parseInt(params.id)}});
        return NextResponse.json({message: 'Article Was Deleted Successfully'}, {status:200});
    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```

يمكننا تجربة ال Delete route handler على ال Postman للتأكد من أن كل شئ على مايرام ،






* خد بالك ، بسبب ال fast refresh الموجودة في Next.js بمعنى أننا في ال development لسنا بحاجة لعمل refresh او reload للصفحة مع كل تغيير ،
* فالتغيير يتم بمجرد الحفظ مباشرة ،
ولكن عند أي تغيير فإنه يتم عمل PrismaClient object من جديد ، ويكون عندنا الكثير من ال prisma object طبقاً لكود ملف utils/db.ts التالي : 
```ts
import { PrismaClient } from "@prisma/client";
const prisma = new PrismaClient();
export default prisma;
```

هذه المشكلة لن تظهر بال Production ، ولكن ستظهر فقط في ال development ، 
الحل المؤقت هو أن يتم وقف ال server وفتحه من جديد من خلال npm run dev ، 

ولكل لحل هذه المشكلة بالمشروع بشكل دائم ، يمكننا كتابة الكود التالي بملف ال db.ts بدلاً من الموجود ، أو يتم عمل comment على الكود الموجود ، ليكون كالتالي : 
```ts
import { PrismaClient } from "@prisma/client";

const prismaClientSingleton = () => {
  return new PrismaClient();
};

declare global {
  var prismaGlobal: undefined | ReturnType<typeof prismaClientSingleton>;
}

const prisma = globalThis.prismaGlobal ?? prismaClientSingleton();

export default prisma;

if (process.env.NODE_ENV !== "production") globalThis.prismaGlobal = prisma;
```




* معلومة أخري : 
لو عملنا اي article بقاعدة البيانات بدون كتابة ال title هيرجع رسالة 'required' ، وللتحكم بنص الرسالة وجعلها كما نريد ، يتم ذلك من خلال ال zod بملف validationSchemas.ts ، كالتالي : 
```ts
import { z } from "zod";

// Validation
export const createArticleSchema = z.object({
    title: z.string({
        required_error: 'The Title Is Required',
        invalid_type_error: 'The Title should be of type string'
    }).min(2).max(200),
    description: z.string().min(10),
});
```

ولو عايز اتحكم في رسالة ال min سيكون كالتالي : 
```ts
min(2, {message: 'Title should be at least 2 characters long'})
```





------------------------------------------------------------------------------------





هنتكلم في هذا ال Commit عن إنشاء حساب مستخدم جديد Register New User بال api من خلال register route handler ،
هنعمل فولدر جديد داخل ال api بإسم (auth) ثم نعمل داخله فولدر باسم register بداخله ملف بإسم route.ts ،

هنعمل import لل NextRequest وال NextResponse كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";
```

ثم نقوم بعمل ال documentation كالتالي : 
```ts
/**
 * @method  POST
 * @route   ~/api/register
 * @desc    Create New Account [ (register) || (sign-up) || (إنشاء حساب) ]
 * @access  public
 */
```

هنعمل ال POST function ونعمل داخلها ال try وال catch كالتالي : 
```ts
export async function POST(request: NextRequest){
    try {
        // Code Here ...
    } catch (error) {
        return NextResponse.json(
            { message: 'Internal Server Error' },
            { status: 500 }
        );
    }
}
```

بداخل ال try هنعمل الأكواد بتاعتنا ،
فأولاً هناخد البيانات من المستخدم كالتالي : 
```ts
const body = await request.json();
```

هحددله البيانات اللي لازم يدخلها كالتالي : 
نقوم بإنشاء interface RegisterUserDto بملف utils/dtos.ts كالتالي : 
```ts
export interface RegisterUserDto{
    username: string;
    email: string;
    password: string;
}
```

ونحدد نوع ال const body انه من نوع RegisterUserDto كالتالي : 
```ts
const body = await request.json() as RegisterUserDto;
```

ومتنساش تعمل import كالتالي : 
```ts
import { RegisterUserDto } from "@/utils/dtos";
```

وبالتالي خدنا البيانات من المستخدم ، هنعمل بعد كده Validation على هذه البيانات ، 
ويتم ذلك من خلال إضافة const registerUserSchema بملف ال validationSchemas.ts كالتالي : 
```ts
// Register User Schema
export const registerUserSchema = z.object({
    username: z.string().min(2).max(100),
    email: z.string().min(3).max(200).email(),
    password: z.string().min(6),
});
```

خد بالك ان كل هذه ال properties ستكون required ، فلو عايزين نجعل أي property منهم يكون اختياري هنضيف ليه ()optional كالتالي : 
```ts
    username: z.string().min(2).max(100).optional(),
```
ولكن لن نستخدم ال optional في هذا ال property فقط للشرح،

بعد كده هنطبق ال validation على ال const body كالتالي : 
```ts
const validation = registerUserSchema.safeParse(body);
```

هنتحقق لو ال validation لم يتحقق فهيرجع رسائل ال error كالتالي : 
```ts
if(!validation.success){
    return NextResponse.json(
        {message: validation.error.errors[0].message},
        {status: 400}
    );
}
```

ولو كان كل ال validation تمام ، هنتحقق بعدها لو كان يوجد مستخدم بهذا الإيميل أم لا ،
فهنبحث بقاعدة البيانات بجدول ال user عن اي record بالإيميل المستلم من المستخدم ، لو الإيميل موجود طلعله رساله بأنه مسجل بالفعل ، وإلا يتم إنشاء حساب جديد ، كالتالي : 
```ts
const user = await prisma.user.findUnique({where:{email: body.email}});
if(user){
    return NextResponse.json(
        { message: 'This User is already registered' },
        { status: 400 }
    )
}

const newUser = await prisma.user.create({
    data:{
        username: body.username,
        email: body.email,
        password: body.password
    }
})

return NextResponse.json(newUser, { status:201 });
```


هنعمل فولدر جديد بال postman بإسم Auth ، 
ونعمل request جديد من نوع POST بالرابط التالي : 
http://localhost:3000/api/register

ثم ندخل عال body ونختار row وندخل البيانات بالشكل التالي : 
```json
{
    "username": "sakr",
    "email": "sakr.bzns@gmail.com",
    "password": "123456"
}
```
بعدها سيتم تسجيل الحساب بنجاح .



ولكن ال password بهذا الشكل غير آمن ، فلابد من عمل تشفير لل password ، 

فلعمل التشفير سنستخدم مكتبة bcryptjs من خلال الأمر التالي : 
```
> npm i bcryptjs
```

ولأن المكتبة معمولة بال javascript وأن مشروعنا بال typscript ، فلازم نعمل types لهذه المكتبة كالتالي : 
```
> npm i -D @types/bcryptjs
```
وطبعاً لو المشروع معمول بال javascript مش هنحتاج نعمل types لل bcryptjs ،



بعد كده هنروح لل auth register route.ts لأن ده اللي هنستخدم في ال bcryptjs ونعمل import لل bcrypt كالتالي : 
```ts
import bcrypt from 'bcryptjs';
```

وعشان نعمل password مشفر ، هنستخدم hash مع ال bcrypt ليكون الكود التالي : 
```ts
const salt = await bcrypt.genSalt(10);
const hashedPassword = await bcrypt.hash(body.password, salt);
const newUser = await prisma.user.create({
    data:{
        username: body.username,
        email: body.email,
        password: hashedPassword
    }
})
```

وبعدها لو عملنا user جديد بال postman هيرجع لنا أن ال password مشفر ويرجع لنا البيانات التالية : 
```json
{
    "id": 2,
    "email": "sakr.bzns2@gmail.com",
    "username": "sakr",
    "password": "$2a$10$wyP5CHRiP83Am0XGP4Ae9eGh2j5zm.ybYvJrGuokRaDrp0BoRRBPe",
    "isAdmin": false,
    "createdAt": "2024-03-17T20:40:32.352Z",
    "updatedAt": "2024-03-17T20:40:32.352Z"
}
```

ويمكن تحديد البيانات اللي ترجع لنا بعد عمل create لل user بنجاح ، وذلك من خلال select object والذي يتم كتابته بعد ال data object داخل create() function كالتالي : 
```ts
const newUser = await prisma.user.create({
    data:{
        username: body.username,
        email: body.email,
        password: hashedPassword
    },
    select:{
        username: true,
        id: true,
        isAdmin: true
    }
})
```
يعني بقول ل Prisma تجيبلي من قواعد البيانات ال username وال id وحالة ال isAdmin فقط ، 


وعلينا أيضاً إرسال token مع البيانات اللي هترجع في حالة تم تسجيل المستخدم بنجاح ، 
وسيتم شرحه لاحقاً ،

فقط هنعمل const token ونرجعه مع البيانات اللي هترجع كالتالي : 
```ts
        // @Todo -> Generate JWT Token
        const token = null;

        return NextResponse.json({...newUser, token}, { status:201 });
```

خد بالك تم إضافة ال ... قبل ال newUser ليتم إرجاع محتوياته مع ال token ، فبإستخدام ال ... تم إرجاع البيانات بالشكل التالي : 
```json
{
    "username": "sakr",
    "id": 6,
    "isAdmin": false,
    "token": null
}
```

ولكن لو تم حذف ال ... ستكون البيانات اللي هترجع بالشكل التالي : 
```json
{
    "newUser": {
        "username": "sakr",
        "id": 8,
        "isAdmin": false
    },
    "token": null
}
```





---------------------------------------------------------------------------------------





نتكلم في هذا ال commit عن ال Login Route Handler ، 
فنقوم بإنشاء ملف ال route.ts داخل api/(auth)/login ، ونقوم بعمل import لل NextRequest وال NextResponse ونبدأ بال POST function ونستخدم try و catch كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";

/**
 * @method  POST 
 * @route   ~/api/login
 * @desc    Login User [(Sign-in) (تسجيل دخول)]
 * @access  public
 */

export async function POST(request: NextRequest){
    try {
        // Code here ...
    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```

هنكتب الكود بتاعنا بعد كده في ال try ،
فأولاً هناخد البيانات من المستخدم من خلال ال request.json كالتالي : 
```ts
const body = await request.json();
```

لابد من كتابة Dto لل Login لأن ال body بهذا الشكل يكون ال type بتاعها عبارة عن any ،
فسنقوم بإنشاء interface بإسم LoginUserDto بملف utils/dtos.ts ليكون كالتالي : 
```ts
export interface LoginUserDto{
    email: string;
    password: string;
}
```

فتم كتابة ال email وال password لأن هذه هي البيانات اللي انا عايز المستخدم يبعتها لل  server ، 

بعد كده هخلي ال const body تاخد خصائصها من ال LoginUserDto عن طريق عمل import ل LoginUserDto وإستخدامها بال const body كالتالي : 
```ts
import { LoginUserDto } from "@/utils/dtos";
```

```ts
const body = await request.json() as LoginUserDto;
```


بعد كده هنعمل Validation عالبيانات اللي بتيجي من ال client ، وذلك من خلال zod بملف validationSchemas.ts كالتالي : 
```ts
// Login User Schema
export const loginUserSchema = z.object({
    email: z.string().min(3).max(200).email(),
    password: z.string().min(6)
})
```

بعد كده هنمرر ال body object بال validation schema كالتالي : 
```ts
import { loginUserSchema } from "@/utils/validationSchemas";
```

```ts
const body = await request.json() as LoginUserDto;
const validation = loginUserSchema.safeParse(body);
```

هنتحقق لو لم تنجح ال validation فهيطلع رسالة error كالتالي : 
```ts
if(!validation.success){
    return NextResponse.json(
        {message: validation.error.errors[0].message},
        {status: 400}
    );
}
```


بعد كده هنجيب بيانات ال user من قواعد البيانات من خلال ال prisma كالتالي : 
```ts
const user = await prisma.user.findUnique({ where:{email: body.email} });
if(!user){
    return NextResponse.json(
        {message: 'Please Create A New Account, You Have No One'},
        {status: 400}
    )
}
```
بالكود السابق تم أيضاً التحقق لو ال email غير موجود ، فهيطلع رسالة Please Create A New Account ،


عايزين نعمل check عال Password ايضاً ، ولكن تذكر ان ال password مشفر من خلال bcrypt ،
هنستخدم ال bcrypt ايضاً للتحقق من إن كان ال password الخاص بال user اللي جالنا ايميله مظبوط ولا لأ ،

فهنستخدم bcrypt.compare() function ، والتي يتم تمرير قيمتين بها ، 
القيمة الأولى عبارة عن ال password اللي بيجي من ال client ، 
القيمة الثانية عبارة عن ال password المشفر اللي بيجي من قاعدة البيانات ،

فتقوم ال bcrypt.compare بعمل مقارنة بين الرقمين ، لو الاتنين بيساوا بعض هترجع true ، ولا يوجد اختلاف فهترجع false ، كالتالي : 
```ts
const isPasswordMatch = await bcrypt.compare(body.password, user.password);
```

بعد كده هنتحقق لو ال isPasswordMatch هتكون false يعني يوجد اختلاف بين ال password المستلم من ال client والموجود بقاعدة البيانات ، فهيطلع رسالة error كالتالي : 
```ts
if(!isPasswordMatch){
    return NextResponse.json(
        {message: 'Password Is Wrong'},
        {status: 400}
    )
}
```

ولو هناك user بالفعل بهذه البيانات المستلمة من ال client ، فهيرجع مؤقتاً رسالة Authenticated وهنرجع معاه token ايضاً ، كالتالي : 
```ts
//@ ToDo -> Generate JWT token
const token = null;

return NextResponse.json(
    {message: 'Authenticated', token},
    {status: 200}
);
```


بعد كده هنعمل request جديد بإسم login بال postman بنوع post ،
وهندخل بيانات اي user ، هنلاقي تم ارجاع authenticated ،


ولكن خد بالك في حالة إن في اي خطأ سواء في ال email او في ال password ، فكل خطأ منهم عملناله message مختلفة عن الأخرى ،
وهنا فلو هناك أي Hacker سيتعرف على نوع الخطأ ويتلاعب عليه ، والأفضل إننا نعطيه نفس ال message حتى لا يمكن للهاكر معرفة البيانات الخطأ نهائياً ،
وهذا هو ال Best Practice  .






----------------------------------------------------------------------------------------------------------





في هذا ال commit هنتكلم عن ال Json Web Token - JWT ،

فمثلاً عند تسجيل دخولك كمستخدم في الفيسبوك ، فإن ال server بيرسل token مشفر لل client ، 
ويتم إرساله مع private key مشفر ، بحيث لو الهاكر عرف يفك ال token مش هيعرف يفك ال private key ، 
وهذا ال token يحتوى على بعض البيانات مثل ال id وال username وهكذا ، 

فعند تسجيل الدخول ، يتم إستلام token من ال server وحفظه بال browser ،
ونستفيد منه عندما يقوم المستخدم بإرسال request سواء لحذف post او اضافة او اي request ، فيتم إرسال ال token لل server ،
يقوم ال server بفك ال token لو تمام هينفذ ال request ،


الموقع الرسمي لل jwt هو :
https://jwt.io/

فال token يكون كالتالي : 
```jwt
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

فسنلاحظ أن ال token مقسم ل 3 أجزاء
HEADER:ALGORITHM & TOKEN TYPE
وهو يحتوي على معلومات مثل ال Algorism المستخدم في تشفير ال token ،
وال type لهذا ال token هو jwt ، 
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

PAYLOAD:DATA
وبه بيانات المستخدم 
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
```


VERIFY SIGNATURE
وهو التوقيع ، وهو عبارة عن ال private key ، 
```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  
your-256-bit-secret

) secret base64 encoded
```


-------

لتسطيب المكتب ، من خلال الأمر التالي : 
```
npm i jsonwebtoken
```

ولأننا نستخدم ال typescript فسيتم تثبيت ال types لل jsonwebtoken كالتالي : 
```
npm i @types/jsonwebtoken -D
```
لاحظ أننا إستخدمنا D- ليتم إضافتها لل devDependencies ، 



هنعمل بقى دلوقتى generate  لل token  ، وذلك من خلال ال login route ، كالتالي 

فأولاً هنعمل import لل jwt كالتالي : 
```ts
import Jwt from "jsonwebtoken";
```

بعد كده هنعمل const token ونجيب قيمتها بإستخدام jwt مع sign() method ، كالتالي : 
```ts
const token = Jwt.sign();
```

حيث أن ال sign تقوم بعمل ال token ، ولكنها تريد بعض ال arguments ، 
أولاً ال payload وهي بيانات المستخدم ،  
فيمكننا عمل const jwtPayload ونخزن فيه بيانات المستخدم ، أي بيانات تريدها ،

ثانياً ال private key ، ويمكنك كتابته بأي اسم تريد مثلا "privatekey19837840993" وهو مهم جداً ولا يجب لأي أحد الحصول عليه ،  

ثالثاً ال signOptions ، وهو اختياري ، ويمكن لنا تحديد مدة ال token بإستخدام expiresIn property ، والتي يتم كتابته في string مثل '30d' لتعبر عن 30 يوم ،
او '2d' أو '10h' لتعبر عن 10 ساعات ، او "5m" لتعبر عن 5 دقائق ، وهكذا ، 

وخد بالك اننا كنا قد مررنا ال token بالسابق ، ليكون الكود في النهاية كالتالي : 

```ts
import prisma from "@/utils/db";
import { LoginUserDto } from "@/utils/dtos";
import { loginUserSchema } from "@/utils/validationSchemas";
import { NextRequest, NextResponse } from "next/server";
import bcrypt from 'bcryptjs';
import Jwt from "jsonwebtoken";

/**
 * @method  POST 
 * @route   ~/api/login
 * @desc    Login User [(Sign-in) (تسجيل دخول)]
 * @access  public
 */

export async function POST(request: NextRequest){
    try {
        const body = await request.json() as LoginUserDto;
        const validation = loginUserSchema.safeParse(body);

        if(!validation.success){
            return NextResponse.json(
                {message: validation.error.errors[0].message},
                {status: 400}
            );
        }

        const user = await prisma.user.findUnique({ where:{email: body.email} });
        
        if(!user){
            return NextResponse.json(
                {message: 'Invalid Email Or Password'},
                {status: 400}
            )
        }

        const isPasswordMatch = await bcrypt.compare(body.password, user.password);

        if(!isPasswordMatch){
            return NextResponse.json(
                {message: 'Invalid Email Or Password'},
                {status: 400}
            )
        }

        const jwtPayload = {
            id: user.id,
            username: user.username,
            isAdmin: user.isAdmin
        }
        const token = Jwt.sign(jwtPayload, "privatekey19837840993", {
            expiresIn: '30d'
        });

        return NextResponse.json(
            {message: 'Authenticated', token},
            {status: 200}
        );

    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```


وبعد ذلك لو فتحنا ال postman وعملنا login بإستخدام ال email وال password كالتالي : 
```json
{
    "email": "sakr@gmail.com",
    "password": "123456"
}
```

فسيتم إرجاع رسالة Authenticated ومعها ال token كالتالي : 
```ts
{
    "message": "Authenticated",
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MywidXNlcm5hbWUiOiJzYWtyIiwiaXNBZG1pbiI6ZmFsc2UsImlhdCI6MTcxMTEyMDkzNSwiZXhwIjoxNzEzNzEyOTM1fQ.XqQXpvCKqr5M6sTiCXC1SupUrJY2OWS-1i-vVLJ5UAE"
}
```

فهذا ال token يحتوى على بيانات ، فممكن ننسخ ال token ونفتح موقع ال jwt.io ونحط ال token فيه ، هنلاحظ التالي : 
أن القسم الأول من ال token كالتالي : 
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
```
يتم فكه ليكون : 
HEADER:ALGORITHM & TOKEN TYPE
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

القسم الثاني : 
```
eyJpZCI6MywidXNlcm5hbWUiOiJzYWtyIiwiaXNBZG1pbiI6ZmFsc2UsImlhdCI6MTcxMTEyMDkzNSwiZXhwIjoxNzEzNzEyOTM1fQ
```
ويتم فكه ليصبح كالتالي : 
PAYLOAD:DATA
```json
{
  "id": 3,
  "username": "sakr",
  "isAdmin": false,
  "iat": 1711120935,
  "exp": 1713712935
}
```

القسم الثالث : هو عبارة عن ال private key ، فهو كالتالي : 
```
XqQXpvCKqr5M6sTiCXC1SupUrJY2OWS-1i-vVLJ5UAE
```

ولكن علينا تحديد قيمة ال private key ليصبح Valid Signature ، كالتالي : 

```json
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  
privatekey19837840993

) secret base64 encoded
```



ولأن ال private key هو سري جداً ، فلا يصح أن يكون في ملفات المشروع المرفوعة على ال github ، ولكننا سنخزنه في ملف ال env كالتالي : 
```
JWT_SECRET=privatekey19837840993
```

ويتم كتابة اسمه بالكود كالتالي ، مع ملاحظة اننا اضفنا as string بسبب ال typescript : 
```ts
const token = Jwt.sign(jwtPayload, process.env.JWT_SECRET as string, {
            expiresIn: '30d'
        });
```


خد بالك هنعمل run لل server مرة أخري ب npm run dev ، وذلك لأننا عملنا تغيير في ملف ال env .


ثم بعد ذلك هنعمل نفس ال token بملف ال register ، 
ولك الأفضل أننا نعمل ملف موحد لذلك بإسم generateToken.ts داخل فولدر utils كالتالي : 
```ts
import Jwt from "jsonwebtoken";

type JWTPayload = {
    id: number,
    username: string,
    isAdmin: boolean
}

export function generateJWT(jwtPayload: JWTPayload) : string {
    const privateKey = process.env.JWT_SECRET as string ;
    const token = Jwt.sign(jwtPayload, privateKey,{
        expiresIn: '30d'
    });

    return token;
}
```

ولكن هننقل ال type JWTPayload بملف ال types.ts لنحصل عليه بأي ملف بأي وقت ، لأننا هنحتاجه في ال login وال register ، 
```ts
export type JWTPayload = {
    id: number,
    username: string,
    isAdmin: boolean
}
```


وبالتالي فإن ملف generateToken.ts سيكون كالتالي : 
```ts
import Jwt from "jsonwebtoken";
import { JWTPayload } from "./types";

export function generateJWT(jwtPayload: JWTPayload) : string {
    const privateKey = process.env.JWT_SECRET as string ;
    const token = Jwt.sign(jwtPayload, privateKey,{
        expiresIn: '30d'
    });

    return token;
}
```


وملف ال login/route.ts سيكون كالتالي : 
```ts
import prisma from "@/utils/db";
import { LoginUserDto } from "@/utils/dtos";
import { loginUserSchema } from "@/utils/validationSchemas";
import { NextRequest, NextResponse } from "next/server";
import bcrypt from 'bcryptjs';
import { generateJWT } from "@/utils/generateToken";
import { JWTPayload } from "@/utils/types";

/**
 * @method  POST 
 * @route   ~/api/login
 * @desc    Login User [(Sign-in) (تسجيل دخول)]
 * @access  public
 */

export async function POST(request: NextRequest){
    try {
        const body = await request.json() as LoginUserDto;
        const validation = loginUserSchema.safeParse(body);

        if(!validation.success){
            return NextResponse.json(
                {message: validation.error.errors[0].message},
                {status: 400}
            );
        }

        const user = await prisma.user.findUnique({ where:{email: body.email} });
        
        if(!user){
            return NextResponse.json(
                {message: 'Invalid Email Or Password'},
                {status: 400}
            )
        }

        const isPasswordMatch = await bcrypt.compare(body.password, user.password);

        if(!isPasswordMatch){
            return NextResponse.json(
                {message: 'Invalid Email Or Password'},
                {status: 400}
            )
        }

        const jwtPayload : JWTPayload = {
            id: user.id,
            username: user.username,
            isAdmin: user.isAdmin
        }
        const token = generateJWT(jwtPayload)

        return NextResponse.json(
            {message: 'Authenticated', token},
            {status: 200}
        );

    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```

وملف ال register/route.ts كالتالي : 
```ts
import prisma from "@/utils/db";
import { RegisterUserDto } from "@/utils/dtos";
import { registerUserSchema } from "@/utils/validationSchemas";
import { NextRequest, NextResponse } from "next/server";
import bcrypt from 'bcryptjs';
import { generateJWT } from "@/utils/generateToken";
import { JWTPayload } from "@/utils/types";

/**
 * @method  POST
 * @route   ~/api/register
 * @desc    Create New Account [ (register) || (sign-up) || (إنشاء حساب) ]
 * @access  public
 */


export async function POST(request: NextRequest){
    try {
        const body = await request.json() as RegisterUserDto;
        const validation = registerUserSchema.safeParse(body);

        if(!validation.success){
            return NextResponse.json(
                {message: validation.error.errors[0].message},
                {status: 400}
            );
        }

        const user = await prisma.user.findUnique({where:{email: body.email}});
        if(user){
            return NextResponse.json(
                { message: 'This User is already registered' },
                { status: 400 }
            )
        }

        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(body.password, salt);
        const newUser = await prisma.user.create({
            data:{
                username: body.username,
                email: body.email,
                password: hashedPassword
            },
            select:{
                username: true,
                id: true,
                isAdmin: true
            }
        })

        const jwtPayload : JWTPayload = {
            id: newUser.id,
            username: newUser.username,
            isAdmin: newUser.isAdmin
        }
        const token = generateJWT(jwtPayload);

        return NextResponse.json({...newUser, token}, { status:201 });
    } catch (error) {
        return NextResponse.json(
            { message: 'Internal Server Error' },
            { status: 500 }
        );
    }
}
```

بعدها لو جربنا ال register في ال postman كالتالي : 
```json
{
    "username": "sakr",
    "email": "sakr9@gmail.com",
    "password": "123456"
}
```

هيطلع النتيجة التالية : 
```json
{
    "username": "sakr",
    "id": 10,
    "isAdmin": false,
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MTAsInVzZXJuYW1lIjoic2FrciIsImlzQWRtaW4iOmZhbHNlLCJpYXQiOjE3MTExNjYyOTQsImV4cCI6MTcxMzc1ODI5NH0.2LIDNAOVTXuWOf31nwHv6_jBaD1tvpc7cScktsTXSGg"
}
```






------------------------------------------------------------------------------------------------------





في هذا ال commit هنعمل delete route handler لل user ، 
وهنخلي ال user فقك هو اللي يقدر يحذف حسابه ، مش اي حد يحذف حساب يوزر تاني يعني ،

فهنعمل route.ts داخل profile ليكون المسار كالتالي : 
~/api/(auth)/profile/[id]

وهنعمل import لل NextRequest وال NextResponse أولاً ، ولل prisma أيضاً ، 
ثم نعمل interface Props لأن هيكون عندنا props ، 
ونعمل ال documentation كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";
import prisma from "@/utils/db";

interface Props {
    params: { id: string }
}

/**
 * @method  Delete
 * @route   ~/api/profile/:id
 * @desc    Delete Profile
 * @access  private
 */
```

وهنجهز كود ال delete route handler ليكون كالتالي : 
```ts
export async function DELETE(request: NextRequest, {params} : Props){
    try {
        // Code ... 
    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```

وفي ال try هنحضر ال user أولاً ، ونتحقق إن لم يكن موجود يطلع رسالة error كالتالي : 
```ts
const user = await prisma.user.findUnique({ where: {id: parseInt(params.id)}});
if(!user){
    return NextResponse.json(
        {message: 'User Not Found'},
        {status: 404}
    )
}
```

ثم بعد ذلك ، لو ال user موجود ، هيتم عمل delete لل user بإستخدام delete function ، ثم نطلع رسالة أنه تم الحذف بنجاح ، كالتالي : 
```ts
await prisma.user.delete({where:{id: parseInt(params.id)}});
return NextResponse.json(
    {message: 'Your Profile Has Been Deleted Successfully'},
    {status: 200}
)
```

ولكن هذا الكود public ، بمعنى أن أي شخص يمكنه حذف أي user ، 
فاحنا عايزينه private بمعنى أن اليوزر يمكنه حذف حسابه فقط ، 

هنعمل request جديد بال postman ب DELETE method وال route يكون كالتالي : 
```
{{DOMAIN}}/api/profile/4
```

لو بإستخدام postman عملنا login بيوزر id = 1 مثلاً ، وحذفنا يوزر id = 2 ، فسيتم الحذف بدون مشاكل ، 
وهذا خطأ في مشروعنا ، فالمفترض أن يكون اليوزر يستطيع حذف حسابه فقط ولا يحذف حساب الآخرين ،

فلجعل هذا ال route يكون private ، فنستطيع استخدام ال token اللي استلمه ال user عند تسجيل الدخول ، ونرسله مع delete request ، 
وسيقوم ال server بإستلام ال token ثم فك التشفير ، ثم بعد أن يفك ال token سيكون عنده بيانات المستخدم ، 
وبعدها ال server هيقارن بين بيانات المستخدم اللي ارسل ال request ، وبيانات المستخدم المطلوب حذفه ، فلو هو نفس المستخدم فسيتم تنفيذ عملية الحذف ، 



يمكننا الحصول على ال token المرسل بال request من خلال ال headers ، 
وزي ماقلنا ان كل token بيكون ليه key وبالتالي للحصول على قيمة ال token فسيكون من خلال headers.keyName ، 

فهنعمل import لل Jwt عشان نفك تشفير ال token ، وهنعمل const بإسم authToken مثلاً ، كالتالي : 
```ts
const authToken = request.headers.authToken;
```
لاحظ أن ال authToken اللي في النهاية دي هي عبارة عن ال Key Name لل token زي ماقلنا ، 
ولكن للعلم هناخد ال auth token من ال cookies ، 

فإحنا عندنا دلوقتي ال authToken مشفر ، فلفك التشفير هنستخدم jwt.verify() method ، واللي بتقبل ال token ، ثم ال private key واللي كنا قد خزناه في env ، كالتالي : 
```ts
const authToken = request.headers.get('authToken') as string;
const userFromToken = Jwt.verify(authToken, process.env.JWT_SECRET as string);
```

هنتحقق من ال authToken ، قبل عمل verify ليكون الكود كالتالي : 
```ts
const authToken = request.headers.get('authToken') as string;
if(!authToken){
    return NextResponse.json(
        {message: 'Not Token Provided, Access Is Denied'},
        {status: 401} // Unauthorized
    )
}
const userFromToken = Jwt.verify(authToken, process.env.JWT_SECRET as string) as JwtPayload;
```

بعدها هنتحقق لو ال userFromToken.id == user.id  فسيتم السماح للمستخدم بمسح ال profile ، كالتالي : 
```ts
if(userFromToken.id == user.id){
    await prisma.user.delete({where:{id: parseInt(params.id)}});
    return NextResponse.json(
        {message: 'Your Profile Has Been Deleted Successfully'},
        {status: 200}
    )
}
```

هتلاحظ خطأ typescript اسفل ال id الخاصة بال userFromToken لعدم تحديد نوعها ، وبالتالي هنحدد النوع في ال const userFromToken كالتالي : 
```ts
const userFromToken = Jwt.verify(authToken, process.env.JWT_SECRET as string) as JwtPayload;
```

فهنجرب بال postman هنلاحظ أنه لابد من تسجيل دخول المستخدم الذي نريد ان يتم حذفه فقط .





----------------------------------------------------------------

هنتكلم في هذا ال commit عن ال Middleware ، 
ال middleware هو route handler بيعمل handle لل request وال response ،

يعنى عنده القدرة إنه يعمل check عال request المرسل من ال client ، ويعطي أيضاً response لل client ،
ال middleware هو من ضمن ال server ، لكن بيشتغل قبل ال server ، 

على سبيل المثال ، ال request المرسل من ال client لل server ، هيمر الأول عال middleware ، ليتحقق أولاً هل هذا ال request عنده token أم لا ،
لو مش عنده token ، فلن يسمح لل request بالدخول عال server ، وهيرسل response لل client ويقوله انك غير authorized ، 

ولو كان عنده token ، فال middleware هيسمح لل request بالدخول لل server ، وبعد كده ال server هيرسل ال response لل client ،
وهكذا يعمل ال middleware ،

وبالتالي فال middleware يقلل ال trafic على ال server من خلال تجنب العديد من ال requests ، 
وينفع أيضاً في المشاريع التى تستعمل ال protected routes ،


لكي يمكننا عمل middleware ، 
لابد أولاً من إنشاء ملف بإسم middleware.ts - هذا الاسم إجباري -
ويتم إنشاء هذا الملف مباشرة داخل ال root folder وهو الفولدر الرئيسي للمشروع في حالة أننا لا نستخدم ال src directory ،
 أو داخل ال src folder لو نستخدم ال src directory ،

فهنكتب بداية كود ال middleware كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";

export function middleware(request: NextRequest){
    console.log('Middleware is called');
}
```
لاحظ أن اسم ال function إجباري أن يكون middleware ،

بهذا الكود فإنه بفتح أي صفحة من المشروع سواء client page أو API route بالمتصفح ، فإنه سيمر أولاً بال middleware وينفذ ال middleware function ثم بعد ذلك يكمل ال request ،



ولتحديد الصفحات المطلوب تطبيق ال middleware عليها ، هنعمل const config ونحدد فيها عناصر ال matcher array ، كالتالي :
```ts
export const config = {
    matcher: ["/"]
}
```
وهذا يعني أن ال middleware سيتم تطبيقه فقط عند فتح ال Home Page والتى مسارها '/' ،


الآن عايزين ال middleware يعمل check على ال token في ال route التالي بال function DELETE : 
api/profile/[id]/route.ts 

حيث أنه تم نسخ ال كود من function DELETE ليكون ال middleware كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";

export function middleware(request: NextRequest){
    const authToken = request.headers.get('authToken') as string;
    if(!authToken){
        return NextResponse.json(
            {message: 'Not Token Provided, Access Is Denied'},
            {status: 401} // Unauthorized
        )
    }
}

export const config = {
    matcher: ["/api/profile/:path*"]
}
```

لاحظ أنه تم كتابة *path: بالنهاية المسار ، وهذا يعني أن يتم تطبيق ال middleware على كل ال routes اللي هتيجي بعد profile/ ،
فلو حذفنا ال route الموجود في ال matcher هيتم تطبيق ال middleware على كل الموقع ، وبالتالي هتلاقي رسالة json طلعت بالصفحة Not Token .... ،
ويمكن إضافة مسارات أخرى داخل ال matcher array ، 

يمكننا حذف كود التحقق if(!authToken) من function DELETE بقى ، ليصبح كود ال function DELETE كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";
import prisma from "@/utils/db";
import Jwt, { JwtPayload } from 'jsonwebtoken';

interface Props {
    params: { id: string }
}

/**
 * @method  Delete
 * @route   ~/api/profile/:id
 * @desc    Delete Profile
 * @access  private
 */


export async function DELETE(request: NextRequest, {params} : Props){
    try {
        const user = await prisma.user.findUnique({ where: {id: parseInt(params.id)}});
        if(!user){
            return NextResponse.json(
                {message: 'User Not Found'},
                {status: 404}
            )
        }

        const authToken = request.headers.get('authToken') as string;
        const userFromToken = Jwt.verify(authToken, process.env.JWT_SECRET as string) as JwtPayload;

        if(userFromToken.id == user.id){
            await prisma.user.delete({where:{id: parseInt(params.id)}});
            return NextResponse.json(
                {message: 'Your Profile Has Been Deleted Successfully'},
                {status: 200}
            )
        }

        return NextResponse.json(
            {message: 'Only User Can Remove His Profile'},
            {status: 403} // Forbidden
        )

        
    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```


ممكن بعد كده يكون عندنا أكتر من method داخل ملف ال route ، ممكن يكون فيه DELETE و GET و PUT وهكذا ،
فلتحديد method معينة يتم تطبيق ال middleware عليها ، فيتم ذلك من خلال علم check على request.method ، كالتالي : 
```ts
if(!authToken && request.method === "DELETE"){
        return NextResponse.json(
            {message: 'Not Token Provided, Access Is Denied'},
            {status: 401} // Unauthorized
        )
    }
```

وبالتالي فإن ال middleware سيتم تطبيقه فقط على DELETE function ، 
هذا الكود للشرح فقط (request.method) ، 
ليصبح الكود النهائي لل middleware كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";

export function middleware(request: NextRequest){
    const authToken = request.headers.get('authToken') as string;
    if(!authToken){
        return NextResponse.json(
            {message: 'Not Token Provided, Access Is Denied'},
            {status: 401} // Unauthorized
        )
    }
}

export const config = {
    matcher: ["/api/profile/:path*"]
}
```


----------------------------------------------------------------------------





نتكلم في هذا ال commit عن ال cookie ،
فبعد أن يقوم المستخدم بعمل login ، فيتم إرجاع token من ال server ، 
ولعمل تعديل او حذف او اي عملية على أي records فسنحتاج ال token ، 

فلازم علينا تخزين هذا ال token بالمتصفح ، عشان لو تم إغلاق الجهاز أو المتصفح وهكذا ،

فعندنا طريقتين لتخزين ال token :
الطريقة الأولى : localstorage ،
فممكن بال formSubmitHander function الموجود في app/(auth)/login/LoginForm.tsx  يتم تخزين ال token بال local storage كالتالي مثلاً : 
```tsx
const jwtToken = 'blablabla';
localStorage.setItem('token', jwtToken);
```
وبالتالي تم تخزين ال token بال localStorage ، ولما احتاج ال token في أي request هنجيبه كالتالي : 
```tsx
localStorage.getItem('token');
```

وال Local Storage هو من ضمن ال client أي من ضمن المتصفح ،
وبالتالي فيمكننا استخدام ال local storage في ال client component ، ولكن لا يمكننا إستخدامه في ال server component ، 
وأنه في بعض الأحيان هيطلع لنا Hydration Error ،


وبالتالي فسنستخدم الطريقة الثانية لتخزين ال token وهي ال Cookie : 
ففي ال cookie يمكننا التحكم فيها من ال server عادي ، وهي أأمن وأفضل ، فلإستخدام ال cookie علينا التالي : 

تسطيب مكتبة cookie كالتالي : 
```
npm i cookie
```

ثم تسطيب ال types لل cookie لأننا نستخدم typescript كالتالي : 
```
npm i @types/cookie -D
```


بعد كده هنروح لملف ال login/ route ونعمل import لل serialize method كالتالي : 
```ts
import { serialize } from "cookie";
```

حيث أن ال serialize هي التى تقوم بعمل cookie ، 

ثم في ال POST قبل كود ال return NextResponse في حالة ال authenticated نقوم بعمل ال cookie كالتالي : 
```ts
const cookie = serialize('jwtToken', token);
```

ونمرر ال cookie هذا في ال headers بإستخدام 'Set-Cookie' كالتالي : 
```ts
const cookie = serialize('jwtToken', token);

return NextResponse.json(
    {message: 'Authenticated'},
    {
        status: 200,
        headers: {'Set-Cookie' : cookie}
    }
);
```
وبالتالي لو عملنا login بإستخدام ال postman هنلاقي انه رجع cookie به ال token ، 
ليتم إستخدامه تلقائياً مع أي request ، 



ولكن ال serialize function لها argument ثالث ، يفضل تحديده وهو options ويحتوي على العديد من العناصر التالية : 
ال httpOnly وقيمته إما false أو true ، هنخليها true فهو يعطي أمان أكثر لل cookie ، كالتالي : 
```ts
const cookie = serialize('jwtToken', token, {
    httpOnly: true,
});
```

ال secure ، وهي تعني أن يكون البروتوكول https وليس http ، فلو فلو كتبنا false فهي تعني http ، 
فحالياً إحنا في مرحلة ال development والتي نستخدم http بها ، وعايزينها تكون https في حالة ال production  ال development ،
وبالتالي هنخزن قيمة تساوي production في env ، ونعمل قيمة ال secure أنها تساوي true لو القيمة المخزنة بال env تساوي production ، كالتالي : 
```
NODE_ENV=development
```

```ts
const cookie = serialize('jwtToken', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production' // development=http, production=https
});
```

ال sameSite نخليها 'strict' وهو يعطي أمان أكثر لل cookie ، كالتالي : 
```ts
const cookie = serialize('jwtToken', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production', // development=http, production=https
    sameSite: 'strict',
});
```

ال path ، يتم تحديد ال path المطلوب تطبيق ال cookie عليه ، ويمكننا تحديد قيمته ب '/' ليتم التطبيق على الموقع بالكامل ، كالتالي : 
```ts
const cookie = serialize('jwtToken', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production', // development=http, production=https
    sameSite: 'strict',
    path: '/',
});
```

ال maxAge ، وفيه يتم تحديد مدة صلاحية ال cookie بالثواني ، ويمكن إستخدام العمليات الحسابية بداخله ، فيمكن ضرب عدد الثواني في الدقائق في الساعة في اليوم في الشهر ، كالتالي : 
```ts
const cookie = serialize('jwtToken', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production', // development=http, production=https
    sameSite: 'strict',
    path: '/',
    maxAge: 60 * 60 * 24 * 30, // 30 days
});
```




ولأن ال token يرجع بمجرد ال login ويتم إستخدامه تلقائياً مع أي request ، 
فلا حاجة لإرسال token بإسم authToken في حالة ال DELETE مثلاً ،

وبالتالي في ملف ال api/profile/[id]/route.ts سنقوم بحذف ال const authToken التالي : 
```
const authToken = request.headers.get('authToken') as string;
```
لأننا سنحصل على ال token من خلال ال cookie كالتالي : 
```ts
const jwtToken = request.cookies.get('jwtToken');
const token = jwtToken?.value as string;
const userFromToken = Jwt.verify(token, process.env.JWT_SECRET as string) as JwtPayload;
```

استخدام علامة ? في الكود للسبب التالي : 
------------------ ChatGPT
في سياق الكود، استخدام العلامة "?" مع "jwtToken?.value" يتيح التحقق مما إذا كانت القيمة المُرجعة من خاصية "value" في كائن "jwtToken" محددة أم لا. إذا كانت القيمة محددة، فإن العبارة "jwtToken?.value" ستعيد القيمة، أما إذا كانت القيمة غير محددة (undefined)، فإن العبارة "jwtToken?.value" ستعيد قيمة undefined بدلاً من رمي خطأ.

هذا يساعد في تجنب وقوع أخطاء (مثل TypeError) في حالة عدم وجود الخاصية "value" في كائن "jwtToken"، ويسهل التعامل مع القيم غير المحددة بشكل آمن ومنظم في سياق البرنامج.
------------------ ChatGPT


وعلينا كتابة نفس الكود في ال middleware ، بدلاً من ال authToken ليكون كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";

export function middleware(request: NextRequest){

    const jwtToken = request.cookies.get('jwtToken');
    const token = jwtToken?.value as string;

    if(!token){
        return NextResponse.json(
            {message: 'Not Token Provided, Access Is Denied'},
            {status: 401} // Unauthorized
        )
    }
}

export const config = {
    matcher: ["/api/profile/:path*"]
}
```



ولأن كود ال serialize function الخاص بعمل ال cookie سنحتاجه في register أيضاً ، فيمكننا عمله في ملف موحد في ال utils أو إضافته بملف generateToken.ts ليكون كالتالي : 
```ts
import Jwt from "jsonwebtoken";
import { JWTPayload } from "./types";
import { serialize } from "cookie";

// Generate JWT Token
export function generateJWT(jwtPayload: JWTPayload) : string {
    const privateKey = process.env.JWT_SECRET as string ;
    const token = Jwt.sign(jwtPayload, privateKey,{
        expiresIn: '30d'
    });

    return token;
}

// Set Cookie With JWT
export function setCookie(jwtPayload: JWTPayload): string{
    const token = generateJWT(jwtPayload);

    const cookie = serialize('jwtToken', token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production', // development=http, production=https
        sameSite: 'strict',
        path: '/',
        maxAge: 60 * 60 * 24 * 30, // 30 days
    });

    return cookie;
}
```

لاحظ أنه تم عمل function بإسم setCookie وهنعملها export عشان نستخدمها بعد كده في الملفات التانية ، 
فقمنا بداخلها بعمل generate لل token في الأول ، ثم قمنا بتخزين ال token في ال cookie بإسم jwtToken ، وال function بالنهاية هترجع cookie .


فنقوم الآن بعمل call أي هنادي ال setCookie function بملف ال login/route.ts بإستخدام import كالتالي : 
```ts
import { setCookie } from "@/utils/generateToken";
```

ثم نعمل const cookie من ال setCookie بدلاً من إستخدام ال serialize مباشرة ، ونمرر فيه ال jwtPayload كالتالي : 
```ts
const cookie = setCookie(jwtPayload);
```

وممكن الأفضل إننا نضع عناصر ال jwtPayload مباشرة داخل ال setCookie لتكون كالتالي : 
```ts
const cookie = setCookie({
    id: user.id,
    username: user.username,
    isAdmin: user.isAdmin
});

return NextResponse.json(
    {message: 'Authenticated'},
    {
        status: 200,
        headers: {'Set-Cookie' : cookie}
    }
);
```


هنحتاج نعمل ال setCookie أيضاً في ال register/route.ts ، ليكون كالتالي : 
```ts
import prisma from "@/utils/db";
import { RegisterUserDto } from "@/utils/dtos";
import { registerUserSchema } from "@/utils/validationSchemas";
import { NextRequest, NextResponse } from "next/server";
import bcrypt from 'bcryptjs';
import { setCookie } from "@/utils/generateToken";

/**
 * @method  POST
 * @route   ~/api/register
 * @desc    Create New Account [ (register) || (sign-up) || (إنشاء حساب) ]
 * @access  public
 */


export async function POST(request: NextRequest){
    try {
        const body = await request.json() as RegisterUserDto;
        const validation = registerUserSchema.safeParse(body);

        if(!validation.success){
            return NextResponse.json(
                {message: validation.error.errors[0].message},
                {status: 400}
            );
        }

        const user = await prisma.user.findUnique({where:{email: body.email}});
        if(user){
            return NextResponse.json(
                { message: 'This User is already registered' },
                { status: 400 }
            )
        }

        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(body.password, salt);
        const newUser = await prisma.user.create({
            data:{
                username: body.username,
                email: body.email,
                password: hashedPassword
            },
            select:{
                username: true,
                id: true,
                isAdmin: true
            }
        })

        const cookie = setCookie({
            id: newUser.id,
            username: newUser.username,
            isAdmin: newUser.isAdmin
        });

        return NextResponse.json(
            {...newUser, message: "Registered & Authenticated"}, 
            { 
                status:201,
                headers:{ "Set-Cookie": cookie } 
            });
    } catch (error) {
        return NextResponse.json(
            { message: 'Internal Server Error' },
            { status: 500 }
        );
    }
}
```



علينا الآن عمل Log Out ، بمعنى أن المستخدم قد يريد أن يخرج من حسابه ويعمل logout ، وبالتالي فعلينا مسح ال cookie ، ليتم الخروج من حسابه ،
فهنعمل ملف route.ts جديد داخل فولدر بإسم logout داخل ال api/(auth) ،

هنكتب الأكواد الأساسية في ال route.ts والخاصة بعمل import لل request وال response وال documentation وال function لتكون كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";

/**
 * @method  GET 
 * @route   ~/api/logout
 * @desc    Logout User [(Sign-out) (تسجيل خروج)]
 * @access  public
 */

export function GET(request: NextRequest){
    try {
        // Code ...
    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```

فعشان نمسح ال cookie هنعمل import لل cookie الموجودة في next/headers كالتالي : 
```ts
import { cookies } from "next/headers";
```

ثم نقوم بحذف ال cookie التي بإسم jwtToken والتى كنا قد أنشأناها ، كالتالي : 
```ts
export function GET(request: NextRequest){
    try {
        cookies().delete("jwtToken");
        return NextResponse.json(
            {message: 'Logout'},
            {status: 200}
        );
    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```

وبالتالي هنعمل request جديد في ال postman ، هنلاقي رجع رسالة Logout ،


بالنسبة لكود ال jwt.verify ، فيمكننا نقله في ملف موحد أفضل ، لأننا سنحتاجه في أماكن اخري بهذا المشروع ،
```ts
const jwtToken = request.cookies.get('jwtToken');
const token = jwtToken?.value as string;
const userFromToken = Jwt.verify(token, process.env.JWT_SECRET as string) as JwtPayload;
```

فهنعمل ملف جديد بإسم verifyToken.ts داخل ال utils ، ليكون كالتالي : 
```ts
import Jwt from 'jsonwebtoken';
import { NextRequest } from "next/server";
import { JWTPayload } from "./types";

export function verifyToken(request: NextRequest) : JWTPayload | null{
    try {
        const jwtToken = request.cookies.get('jwtToken');
        const token = jwtToken?.value as string;
        if(!token) return null;

        const privateKey = process.env.JWT_SECRET as string;
        const userPayload = Jwt.verify(token, privateKey) as JWTPayload;
        return userPayload;
    } catch (error) {
        return null;
    }
}
```

فوظيفة هذا ال function أن يفتح تشفير ال token ، ويعمل له verify ، فبأي مكان بالمشروع لو محتاج عمل verify لل token ، هنعمل import و call لل function ، 
هناخل ال jwtToken من ال cookie ، وفي هذا ال cookie هناخد منه ال token ، فلو لم يكن ال token موجود هنرجع null ، 
وإلا هنكمل ونستعيد قيمة ال private key من ال env ، 
ثم نعمل verify لل token بمقارنة ال token مع ال private key ، 
ولو كله تمام هنرجع userPayload ،


هنستخدم هذا ال function كالتالي : في ملف profile/[id]/route.ts بال DELETE function 
هنعمل import ل verifyToken كالتالي : 
```ts
import { verifyToken } from "@/utils/verifyToken";
```

ثم هنمسح الأكواد التالية : 
```ts
const jwtToken = request.cookies.get('jwtToken');
const token = jwtToken?.value as string;
const userFromToken = Jwt.verify(token, process.env.JWT_SECRET as string) as JwtPayload;
```


 ثم هنعمل ال const userFromToken لتصبح كالتالي : 
```ts
const userFromToken = verifyToken(request);
```

بعد كده هنعمل check لو ال userFromToken لا تساوي null ، و userFromToken.id تساوي user.id فيتم الحذف بنجاح ، ليكون الكود كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";
import prisma from "@/utils/db";
import Jwt, { JwtPayload } from 'jsonwebtoken';
import { verifyToken } from "@/utils/verifyToken";

interface Props {
    params: { id: string }
}

/**
 * @method  Delete
 * @route   ~/api/profile/:id
 * @desc    Delete Profile
 * @access  private
 */


export async function DELETE(request: NextRequest, {params} : Props){
    try {
        const user = await prisma.user.findUnique({ where: {id: parseInt(params.id)}});
        if(!user){
            return NextResponse.json(
                {message: 'User Not Found'},
                {status: 404}
            )
        }

        const userFromToken = verifyToken(request);

        if(userFromToken !== null && userFromToken.id == user.id){
            await prisma.user.delete({where:{id: parseInt(params.id)}});
            return NextResponse.json(
                {message: 'Your Profile Has Been Deleted Successfully'},
                {status: 200}
            )
        }

        return NextResponse.json(
            {message: 'Only User Can Remove His Profile'},
            {status: 403} // Forbidden
        )

        
    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```

وهنا يمكننا عمل check بال postman لل register وال login وال logout وال delete functions ، سنجد أن كل شئ على ما يرام .



----------------------------------------------------------------------------




في هذا ال commit هنعمل GET route handler وال PUT route handler لل user profile ،
فبنفس ملف ال api/(auth)/profile/[id]/route.ts هنعمل ال GET وال PUT أيضاً ،

فستكون ال GET كالتالي : 
```ts
/**
 * @method  GET
 * @route   ~/api/profile/:id
 * @desc    Get Profile By Id
 * @access  private
 */
export async function GET(request : NextRequest, {params} : Props){
    try {
        const user = await prisma.user.findUnique({where: {id: parseInt(params.id)}});

        if(!user){
            return NextResponse.json(
                {message: 'User Not Found'},
                {status: 404}
            )
        }

        const userFromToken = verifyToken(request);
        if(userFromToken === null || userFromToken.id != user.id){
            return NextResponse.json(
                {message: 'You Are Not Allowed, Access Denied'},
                {status: 403}
            )
        }

        return NextResponse.json(user, {status: 200});

    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```

هنعمل request جديد بال postman بإسم show بال route التالي : 
```
{{DOMAIN}}/api/profile/13
```
وبال GET method ، سنجد أنه قام بإرجاع بيانات ال user ، 
سنجد أيضاً أنه تم إرجاع ال password المشفر مع البيانات اللي رجعت ، 
ولتحديد البيانات اللي عايزين نحصل عليها من ال user ، من خلال select بال prisma في ال const user ليكون كالتالي : 
```ts
const user = await prisma.user.findUnique({
    where: {id: parseInt(params.id)},
    select:{
        id: true,
        email: true,
        username: true,
        createdAt: true,
        isAdmin: true
    }
});
```
وبالتالي فإن ال properties المحددة فقط هي اللي هترجع ، 



بعد كده نعمل ال PUT route handler ، واللي هتكون الأكواد الأوليه له كالتالي : 
```ts

/**
 * @method  PUT
 * @route   ~/api/profile/:id
 * @desc    Update Profile By Id
 * @access  private
 */
export async function PUT(request : NextRequest, {params} : Props){
    try {
        const user = await prisma.user.findUnique({where: {id: parseInt(params.id)}});

        if(!user){
            return NextResponse.json(
                {message: 'User Not Found'},
                {status: 404}
            )
        }

        const userFromToken = verifyToken(request);
        if(userFromToken === null || userFromToken.id != user.id){
            return NextResponse.json(
                {message: 'You Are Not Allowed, Access Denied'},
                {status: 403}
            )
        }

        // Code of updating user data ....

    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```

ثم بعد ذلك هنجيب البيانات اللي المستخدم بعتها بال request كالتالي : 
```ts
const body = await request.json();
```
ولكن هذه البيانات من نوع any ، وبالتالي علينا تحديد بيانات حقول ال request من خلال إنشاء Dto جديد بملف ال utils/dtos.ts كالتالي : 
```ts
export interface UpdateUserDto{
    username?: string;
    email?: string;
    password?: string;
}
```
وطبعاً لأن الحقول المعدلة هتكون إختياري فتم وضع علامة ال ? ، بمعنى أن المستخدم قد يريد تعديل اليوزرنيم ولا يريد تعديل الإيميل ، وهكذا ...

بعد كده هنعمل Import لل Dto كالتالي : 
```ts
import { UpdateUserDto } from "@/utils/dtos";
```
ثم نحدد نوع ال const body ك UpdateUserDto كالتالي : 
```ts
const body = await request.json() as UpdateUserDto ;
```

فبعد أن تم إحضار بيانات ال user المسجلة بال database ، وتم إحضار البيانات المستلمة من المستخدم بحقول التعديل ، 
فسنقوم بإستخدام prisma update function لتنفيذ تعديل البيانات كالتالي : 
```ts
const body = await request.json() as UpdateUserDto ;

const updatedUser = await prisma.user.update({
    where: {id: parseInt(params.id)},
    data:{
        username: body.username,
        email: body.email,
        password: body.password
    }
});

return NextResponse.json( updatedUser, {status: 200});
```

ولكن عندنا مشكلة في الكود السابق ، وهو تشفير ال password ، بمعنى إننا لازم نشفر ال password لو هيتم تعديله ، ولو لم يتم تعديله فلن نفعل شئ به ،
ويتم ذلك أولاً من خلال عمل import لل bcrypt.js كالتالي : 
```ts
import bcrypt from 'bcryptjs';
```

ثم هنعمل كود من خلاله هنتحقق لو يوجد password مرسل في ال body ، فهيتم تشفير ال body.password وإرساله ، كالتالي : 
```ts
const body = await request.json() as UpdateUserDto ;

if(body.password){
    const salt = await bcrypt.genSalt(10);
    body.password = await bcrypt.hash(body.password, salt);
}
const updatedUser = await prisma.user.update({
    where: {id: parseInt(params.id)},
    data:{
        username: body.username,
        email: body.email,
        password: body.password
    }
});
```

هنعمل request جديد بال postman بنوع PUT بإسم update بال route التالي : 
```
{{DOMAIN}}/api/profile/13
```
ونقوم فيها بتعديل البيانات كما نريد ، 

سنجد أنه يتم إرجاع ال password مع البيانات اللي راجعة ، وبالتالي يمكننا إستخدام ال prisma select لتحديد البيانات اللي هترجع ،
أو ممكن نستخدم الطريقة الإعتيادية لل javascript كالتالي : 
```ts
const {password, ...other} = updatedUser;
return NextResponse.json( {...other}, {status: 200});
```
وهذا يعني أن يتم إرجاع كل ال properties ماعدا ال password .

----------------------------------------------------------------------------



في هذا ال commit هنعمل ال comment route
لأننا عندنا Article وله Comments ، 
وكنا عملنا ال Comment Model في ملف ال schema.prisma كالتالي : 
```prisma
model Comment{
  id Int @id @default(autoincrement())
  text String
  createdAt DateTime @default(now())
  updatedAt DateTime  @updatedAt
  articleId Int
  userId Int

  // One-To-Many Relation between Article & Comment
  article Article @relation(fields: [articleId], references: [id])

  // One-To-Many Relation between User & Comment
  user  User @relation(fields: [userId], references: [id])
}
```

أولاً هنعمل فولدر جديد بإسم comments داخل ال api ، وداخله route.ts ، 
هنعمل import لل request , response ،
بعد كده هنعمل ال documentation ، وهنجهز الكود كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";

/**
 * @method  POST
 * @route   ~/api/comments
 * @desc    Create A New Article
 * @access  private (Only Logged-In Users)
*/

export function POST(request: NextRequest){
    try {
        // Code ...
    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```

بعد كده عايزين نعمل verify لل Token ونشوف هل هذا ال user عنده token أي مسجل دخول ولا لأ ، 
وذلك من خلال عمل import لل verifyToken اللي عملناها في ال utils ، واللي كانت بترجع إما ال payload أو null ، فكانت كالتالي للتذكرة :
```ts
import Jwt from 'jsonwebtoken';
import { NextRequest } from "next/server";
import { JWTPayload } from "./types";

export function verifyToken(request: NextRequest) : JWTPayload | null{
    try {
        const jwtToken = request.cookies.get('jwtToken');
        const token = jwtToken?.value as string;
        if(!token) return null;

        const privateKey = process.env.JWT_SECRET as string;
        const userPayload = Jwt.verify(token, privateKey) as JWTPayload;
        return userPayload;
    } catch (error) {
        return null;
    }
}
```

عشان نستخدمها في ال api/comments/route.ts هنعمل import لها كالتالي :  
```ts
import { verifyToken } from "@/utils/verifyToken";
```

ثم نستخدمها بتمرير ال request لها ، وإما هترجع لنا null فيعني أن ال user ليس له token ، وإما هترجع ال payload ، كالتالي : 

```ts
try {
        const user = verifyToken(request);

        if(!user){
            return NextResponse.json(
                {message: 'Only Logged-in Users Can Access'},
                {status: 401}
            )
        }
    }
```
بعد كده ، هناخد البيانات اللي جاية من حقول الإدخال ، كالتالي : 
```ts
const body = await request.json();
```

ولكن كالعادة ، فهذا ال body من نوع any ، 
فعلينا كتابة Dto لل create comment بملف ال utils/dtos.ts ، ليكون كالتالي : 
```ts
export interface CreateCommentDto{
    text: string;
    articleId: number;
}
```

بعد كده هنعرف ال const body انه من نوع CreateCommentDto ، عن طريق عمل import ثم استخدامها كالتالي : 
```ts
import { CreateCommentDto } from "@/utils/dtos";
```

```ts
const body = await request.json() as CreateCommentDto;
```

بعد كده هنعمل validation بملف ال utils/validationSchema.ts كالتالي : 
```ts
// Create Comment Schema
export const createCommentSchema = z.object({
    text: z.string().min(2).max(50),
    articleId: z.number(),
});
```

بعد كده هنطبق ال validation على البيانات اللي جاية من ال body كالتالي : 
```ts
const body = await request.json() as CreateCommentDto;

const validation = createCommentSchema.safeParse(body);
if(!validation.success){
    return NextResponse.json(
        {message: validation.error.errors[0].message},
        {status: 400}
    )
}
```

فلو ال validation تحقق بنجاح ، سيتم إنشاء ال comment بإستخدام prisma.create كالتالي : 
```ts
const newComment = await prisma.comment.create({
    data: {
        text: body.text,
        articleId: body.articleId,
        userId: user.id
    }
});

return NextResponse.json(newComment, {status: 201});
```

ليكون الكود كاملاً بالنهاية هكذا : 
```ts
import { NextRequest, NextResponse } from "next/server";
import prisma from "@/utils/db";
import { verifyToken } from "@/utils/verifyToken";
import { CreateCommentDto } from "@/utils/dtos";
import { createCommentSchema } from "@/utils/validationSchemas";

/**
 * @method  POST
 * @route   ~/api/comments
 * @desc    Create A New Article
 * @access  private (Only Logged-In Users)
*/

export async function POST(request: NextRequest){
    try {
        const user = verifyToken(request);

        if(!user){
            return NextResponse.json(
                {message: 'Only Logged-in Users Can Access'},
                {status: 401}
            )
        }

        const body = await request.json() as CreateCommentDto;

        const validation = createCommentSchema.safeParse(body);
        if(!validation.success){
            return NextResponse.json(
                {message: validation.error.errors[0].message},
                {status: 400}
            )
        }

        const newComment = await prisma.comment.create({
            data: {
                text: body.text,
                articleId: body.articleId,
                userId: user.id
            }
        });

        return NextResponse.json(newComment, {status: 201});

    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```

ننتقل بعد ذلك لل postman و نعمل فولدر جديد بإسم comments ، وداخله request جديد من نوع POST بال route التالي : 
```
{{DOMAIN}}/api/comments
```

ثم من خلال raw هندخل بيانات كالتالي : 
```json
{
    "text": "This is 1st Comment",
    "articleId": 1
}
```

هنجد أنه تم إضافة ال comment بنجاح ، ولو لم يتم عمل login لل user هيطلع رسالة "Only Logged-in Users Can Access" ، 



بعد كده هنعمل GET route handler لل comment بنفس ال route.ts ، ليكون كالتالي :  
```ts
/**
 * @method  GET
 * @route   ~/api/comments
 * @desc    Get All Comments
 * @access  private (Only Admins)
*/

export async function GET(request: NextRequest){
    try {
        const user = verifyToken(request);

        if(user === null || user.isAdmin === false){
            return NextResponse.json(
                {message: 'Only Admins Can Access'},
                {status: 401}
            )
        }

        const comments = await prisma.comment.findMany();
        return NextResponse.json(comments, {status: 200});

    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```

بعد كده هنعمل request جديد بال postman بنوع GET بال route التالي : 
```
{{DOMAIN}}/api/comments
```

ليقوم بعرض كل ال comments الموجودة عندي ، 
وخد بالك إننا عملنا شرط أن يكون ال user عبارة عن admin ، يعنى ال isAdmin = true ، 
فهنضطر نعدل قيمة ال isAdmin من ال prisma studio مباشرة لل user اللي هنعمل بيه login في ال postman ، 
وبعد كده هنلاقي إنه تم عرض مل ال comments ، 



** خد بالك عندنا خطأ في حاجة ، اللي هي تعديل بيانات ال user ،
المفترض إن ال validation عند إنشاء user جديد أن يكون الباسورد اقل حاجة له هو 6 ارقام ،

ولكن عند التعديل ، هذا الشرط غير شغال ، لأننا مش حددناه ،
وبالتالي يمكننا تحديد الشرط ، ممكن بإستخدام ملف ال validationSchema.ts ككل مرة ،
ولكن هذه المرة هنستخدم شرط if عادي في api/(auth)/profile/[id]/route.ts بال function PUT ، ليكون الكود كالتالي : 
```ts
// Code of update user data ....
const body = await request.json() as UpdateUserDto ;

if(body.password){
    if(body.password.length < 6){
        return NextResponse.json(
            {message: 'Password length must be 6 characters at least'},
            {status: 400}
        )
    }
    const salt = await bcrypt.genSalt(10);
    body.password = await bcrypt.hash(body.password, salt);
}
```


----------------------------------------------------------------------------



في هذا ال commit هنعمل ال update وال delete لل comment ، من خلال ال PUT, DELETE route handler ،

فهنعمل دلوقتى فولدر بإسم [id] داخل ال api/comments ، وداخل هذا الفولدر هنعمل route.ts كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";
import prisma from "@/utils/db";

interface Props{
    params: {id: string}
}

/**
 * @method  PUT
 * @route   ~/api/comments/:id
 * @desc    Update Comment By Id
 * @access  private (only the writer of this comment)
 */
export async function PUT(request: NextRequest, {params}: Props){
    try {
        const comment = await prisma.comment.findUnique({
            where: {id: parseInt(params.id)}
        });
    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```

حيث أننا حضرنا ال comment من قاعدة البيانات بإستخدام ال prisma ، 

بعد كده هنتحقق من ال comment لو مش موجود هنرجع رسالة انه غير موجود ، كالتالي : 
```ts
if(!comment){
    return NextResponse.json(
        {message: 'This Comment Is Not Found'},
        {status: 404}
    )
}
```

فلو كله تمام وال comment موجود ، فهنعمل verify لل token عشان نشوف إن ال user عنده صلاحية للتعديل على هذا ال comment أم لا ، كالتالي : 
```ts
const user = verifyToken(request);
if(user === null || user.id !== comment.userId){
    return NextResponse.json(
        {message: 'You Are Not Allowed'},
        {status: 403}
    )
}
```

فلو كل شئ تمام كده ، هنسمح للمستخدم بعمل تعديل لل comment ، وذلك من خلال الحصول على البيانات اللي دخلها ال user الأول ، كالتالي : 
```ts
const body = await request.json();
```

ولكن هذا ال body حالياً من نوع any فهنعمل Dto له بملف ال utils/dtos.ts كالتالي : 
```ts
export interface UpdateCommentDto{
    text: string;
}
```

فهنعمل import لل UpdateCommentDto لإستخدامها كالتالي : 
```ts
import { UpdateCommentDto } from "@/utils/dtos";
.
.
.
const body = await request.json() as UpdateCommentDto;
```

ثم نقوم بكتابة كود ال update بإستخدام ال prisma ، وهنرجع ايضاً البيانات اللي تعدلت ، كالتالي : 
```ts
const updatedComment = await prisma.comment.update({
    where: {id: parseInt(params.id)},
    data: {
        text: body.text
    }
});

return NextResponse.json(updatedComment,{status: 200});
```

ليكون الكود بالنهاية كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";
import prisma from "@/utils/db";
import { verifyToken } from "@/utils/verifyToken";
import { UpdateCommentDto } from "@/utils/dtos";

interface Props{
    params: {id: string}
}

/**
 * @method  PUT
 * @route   ~/api/comments/:id
 * @desc    Update Comment By Id
 * @access  private (only the writer of this comment)
 */
export async function PUT(request: NextRequest, {params}: Props){
    try {
        const comment = await prisma.comment.findUnique({
            where: {id: parseInt(params.id)}
        });

        if(!comment){
            return NextResponse.json(
                {message: 'This Comment Is Not Found'},
                {status: 404}
            )
        }

        const user = verifyToken(request);
        if(user === null || user.id !== comment.userId){
            return NextResponse.json(
                {message: 'You Are Not Allowed'},
                {status: 403}
            )
        }

        const body = await request.json() as UpdateCommentDto;
        const updatedComment = await prisma.comment.update({
            where: {id: parseInt(params.id)},
            data: {
                text: body.text
            }
        });

        return NextResponse.json(updatedComment,{status: 200});

    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```


بعد كده هنعمل request جديد بال postman ، من نوع put بإسم update بال route التالي : 
```
{{DOMAIN}}/api/comments/1
```
هنلاقي كله تمام ، وأن التعديل لازم يكون من خلال ال user صاحب ال comment .




بعد كده عايزين نعمل ال DELETE route handler كالتالي : 
```ts
/**
 * @method  DELETE
 * @route   ~/api/comments/:id
 * @desc    Delete Comment By Id
 * @access  private (only Admin or the writer of this comment)
 */
export async function DELETE(request: NextRequest, {params}: Props){
    try {
        const comment = await prisma.comment.findUnique({
            where: {id: parseInt(params.id)}
        });

        if(!comment){
            return NextResponse.json(
                {message: 'This Comment Is Not Found'},
                {status: 404}
            )
        }

        const user = verifyToken(request);
        if(user === null){
            return NextResponse.json(
                {message: 'No Token Provided, Access Denied'},
                {status: 401}
            )
        }

        if(user.isAdmin || user.id === comment.userId){
            await prisma.comment.delete({
                where: {id: parseInt(params.id)}
            });

            return NextResponse.json(
                {message: 'Comment Deleted Successfully'},
                {status: 200}
            )
        }

        // In case of user not admin, and not the writer of the comment
        return NextResponse.json(
            {message: 'You Are Not Allowed'},
            {status: 403}
        )
    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```
بعد كده هنعمل request جديد بال postman ، من نوع delete بإسم delete بال route التالي : 
```
{{DOMAIN}}/api/comments/1
```
هنلاقي كله تمام ، وأن الحذف لازم يكون من خلال ال user صاحب ال comment أو من الأدمن .


----------------------------------------------------------------------------



في هذا ال commit هنعمل ال Pagination ، بمعنى ترقيم الصفحات ،
عشان هنطبق عال articles page فهنضيف اكثر من 20 article بقاعدة البيانات بجدول articles ، 
ممكن من خلال postman او prisma studio او phpMyAdmin ، 

ففي صفحة ال aritcles هنبعت ال api ليتم عرض كل ال articles الخاصة بنا ،
فاحنا عايزين نعمل pagination بحيث كل صفحة يتم عرض 6 articles بها ، 

فخد بالك اننا هنستعمل query string لتحديد رقم الصفحة بال route 
فمثلاً  domain/articles?pageNumber=2 ، وهكذا ،
فهنا تم ارسال request لل server بأن يجلب بيانات ال articles كلها ، الخاصة بالصفحة الثانية ،
ولكن علينا أيضاً تحديد عدد ال articles في الصفحة الواحدة ليحدد ال articles بالضبط ،

فلعمل كل هذا : هندخل على ال api/articles/route.ts عند ال GET method ، والذي يتم عرض كل ال articles من خلالها ، والتعديل عليها ،
حيث أنها قبل التعديل كانت كالتالي : 
```ts
/**
 * @method  GET
 * @route   ~/api/articles
 * @desc    Get All Articles
 * @access  public
 */
export async function GET(request: NextRequest) {
    try {
        const articles = await prisma.article.findMany();
        return NextResponse.json(articles, {status: 200});
    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```

فللحصول على قيمة ال query string من ال link ، يتم ذلك بإستخدام التالي : 
```ts
request.nextUrl.searchParams.get('query_string_name');
```

فهنا عايزين نعمل query string بإسم pageNumber ، كالتالي : 
```ts
const pageNumber = request.nextUrl.searchParams.get('pageNumber');
console.log(pageNumber);
```

هنروح بعد كده للكود الخاص بجلب ال articles التالي : 
```ts
const articles = await prisma.article.findMany();
```
فال findMany بتجيب لنا كل ال articles ، يمكننا تحديد بعض الشروط بال findMany كالتالي : 
```ts
const articles = await prisma.article.findMany({
    skip: 0,
    take: 6
});
```
وهذا يعنى أن يتم الحصول على كل ال articles ولكن يترك ال article صفر ، ثم يعرض ال 6 articles التالية للصفر ، 
وهذا تعنى الصفحة الأولي ، فبو عايزين الصفحة الثانية ستكون كالتالي : 
```ts
const articles = await prisma.article.findMany({
    skip: 6,
    take: 6
});
```
ولكن طبعاً قيم ال skip وال take لابد أن تكون dynamic ، 
فاحنا عملنا const pageNumber ، هنعمل const ARTICLES_PER_PAGE كالتالي : 
```ts
const pageNumber = request.nextUrl.searchParams.get('pageNumber');
const ARTICLES_PER_PAGE = 6;

const articles = await prisma.article.findMany({
    skip: 6,
    take: ARTICLES_PER_PAGE
});
```

وبالنسبة لقيمة skip ، فالمفترض انها تساوي : 
```ts
skip: ARTICLES_PER_PAGE * ( pageNumber - 1),
```
ولكن هنلاقي خطأ بال ts بنوع ال pageNumber ، لأن المفترض قيمتها تكون string ، واحنا بنستخدمها في عملية حسابية ك number ، 
وبالتالي فعلينا تحويلها ل integer كالتالي : 
```ts
skip: ARTICLES_PER_PAGE * ( parseInt(pageNumber) - 1),
```

هنلاقي خطأ تانى ، بال ts كالتالي : 
Argument of type 'string | null' is not assignable to parameter of type 'string'.
  Type 'null' is not assignable to type 'string'.ts(2345)
وهو يعنى أن ال pageNumber قد يكون null ، 
فلهذا هنروح لل const pageNumber ، ونضيف "1" في حالة null ، ولاحظ أن "1" ستكون string وليست integer ، كالتالي : 
```ts
const pageNumber = request.nextUrl.searchParams.get('pageNumber') || "1";
```

فبالمستقبل لونريد زيادة عدد ال articles بالصفحة ، فيمكننا تعديل قيمة ال const ARTICLES_PER_PAGE ، 
ولكن للتسهيل والتنظيم ، هنعمل ملف خاص بال constants داخل ال utils بإسم constants.ts ونخزن فيه ال const ARTICLES_PER_PAGE ، كالتالي : 
```ts
export const ARTICLES_PER_PAGE = 6;
```
ونعمل له import بال articles/route.ts لإستخدامه في ال GET method ليكون الكود بالنهاية كالتالي : 
```ts
import { NextRequest, NextResponse } from "next/server";
import prisma from "@/utils/db";
import { ARTICLES_PER_PAGE } from "@/utils/constants";


/**
 * @method  GET
 * @route   ~/api/articles
 * @desc    Get All Articles By Page Number
 * @access  public
 */
export async function GET(request: NextRequest) {
    try {
        const pageNumber = request.nextUrl.searchParams.get('pageNumber') || "1";

        const articles = await prisma.article.findMany({
            skip: ARTICLES_PER_PAGE * ( parseInt(pageNumber) - 1),
            take: ARTICLES_PER_PAGE
        });
        return NextResponse.json(articles, {status: 200});
    } catch (error) {
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```


------------

بنفس ملف ال route.ts بال POST method ، احنا كنا عاملين ال POST method يكون public ، بمعنى ان أي شخص يقدر يعمل article جديد ، 
ولكننا نريد يكون متاح فقط لل admin ، 
حيث أن الكود كان كالتالي : 
```ts
/**
 * @method  POST
 * @route   ~/api/articles
 * @desc    Create A New Article
 * @access  public
*/
export async function POST(request: NextRequest){
    try{
        const body = await request.json() as CreateArticleDto;

        const validation = createArticleSchema.safeParse(body);
    
        if(!validation.success){
            return NextResponse.json({message: validation.error.errors[0].message}, {status: 400});
        }
    
        const newArticle:Article = await prisma.article.create({
            data:{
                title: body.title,
                description: body.description
            }
        })
        return NextResponse.json(newArticle, {status:201});
    }catch(error){
        return NextResponse.json(
            {message: 'Internal Server Error'},
            {status: 500}
        )
    }
}
```

وبالتالي علينا أننا ناخد ال token من المستخدم ونعمل verify لل token ، ونتحقق هل هو admin أم لا ، وذلك من خلال verifyToken function اللى أنشأناها من قبل ، كالتالي : 
```ts
try{
        const user = verifyToken(request);
        if(user === null || user.isAdmin === false){
            return NextResponse.json(
                {message: 'Only Admin Can Create Article'},
                {status: 403}
            )
        }

        const body = await request.json() as CreateArticleDto;

        const validation = createArticleSchema.safeParse(body);
    
        if(!validation.success){
            return NextResponse.json({message: validation.error.errors[0].message}, {status: 400});
        }
    
        const newArticle:Article = await prisma.article.create({
            data:{
                title: body.title,
                description: body.description
            }
        })
        return NextResponse.json(newArticle, {status:201});
    }catch(error){.........etc.......}
```

هنعمل نفس الحاجة في ال PUT method وال DELETE method ليكون تعديل ال Article فقط من خلال ال admin .


----------------------------------------------------------------------------


